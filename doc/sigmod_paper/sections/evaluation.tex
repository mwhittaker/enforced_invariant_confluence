\section{Evaluation}\seclabel{Evaluation}
In this section, we describe and evaluate Lucy: a prototype implementation of
our decision procedures and system models. A more complete evaluation can be
found in \cite{whittaker2018interactive}.

Lucy includes an implementation of the interactive decision procedures
described in \algoref{InteractiveDecisionProcedure} and
\algoref{ArbitraryStartInteractiveDecisionProcedure}. The decision procedures
are implemented in roughly 2,500 lines of Python. We use Z3~\cite{de2008z3} to
implement our \invariantclosure{} decision procedure. Lucy also includes an
implementation of the \invariantconfluence{} and segmented
\invariantconfluence{} system models in roughly 3,500 lines of C++. Users
specify objects, transactions, invariants, and segmentations in C++. Lucy then
replicates the objects using segmented \invariantconfluence{}. We now evaluate
the practicality and efficiency of our decision procedure prototypes.

\example[Foreign Keys]\examplelabel{ForeignKeysEval}
A 2P-Set $X = (A_X, R_X)$ is a set CRDT composed of a set of additions $A_X$
and a set of removals $R_X$~\cite{shapiro2011comprehensive}. We view the state
of the set $X$ as the difference $A_X - R_X$ of the addition and removal sets.
To add an element $x$ to the set, we add $x$ to $A_X$. Similarly, to remove $x$
from the set, we add it to $R_X$. The merge of two 2P-sets is a pairwise union
(i.e. $(A_X, R_X) \join (A_Y, R_Y) = (A_X \cup A_Y, R_X \cup R_Y)$).

We can use 2P-sets to model a simple relational database with foreign key
constraints. Let object $O = (X, Y) = ((A_X, R_X), (A_Y, R_Y))$ consist of a
pair of two 2P-Sets $X$ and $Y$, which we view as relations. Our invariant $X
\subseteq Y$ (i.e. $(A_X - R_X) \subseteq (A_Y - R_Y)$) models a foreign key
constraint from $X$ to $Y$. We ran our decision procedure on the object with
initial state $((\emptyset, \emptyset), (\emptyset, \emptyset))$ and with
transactions that allow arbitrary insertions and deletions into $X$ and $Y$.
After less than a tenth of a second, the decision procedure produced a
reachable counterexample witnessing the fact that the object is not
\invariantconfluent{}. A concurrent insertion into $X$ and deletion from $Y$
can lead to a state that violates the invariant. This object is not
\invariantconfluent{} and therefore not \invariantclosed{}.
Thus, existing systems that depend on \invariantclosure{} as a sufficient
condition are unable to conclude definitively that the object is \emph{not}
\invariantconfluent{}.

We also reran the decision procedure, but this time with insertions into $X$
and deletions from $Y$ disallowed. In less than a tenth of a second, the
decision procedure correctly deduced that the object is now
\invariantconfluent{}. These results were manually proven
in~\cite{bailis2014coordination}, but our tool was able to confirm them
automatically in a negligible amount of time.

\example[Escrow Transactions]\examplelabel{EscrowTransactionsEval}
Escrow transactions are a concurrency control technique that allows a database
to execute transactions that increment and decrement numeric values with more
concurrency than is otherwise possible with general-purpose techniques like
two-phase locking~\cite{o1986escrow}. The main idea is that a portion of the
numeric value is put in escrow, after which a transaction can freely decrement
the value so long as it is not decremented by more than the amount that has
been escrowed. We show how segmented \invariantconfluence{} can be used to
implement escrow transactions.

Consider again the PN-Counter $s = (p_1, p_2, p_3), (n_1, n_2, n_3)$ from
\exampleref{CounreachableExample} replicated on three servers with transactions
to increment and decrement the PN-Counter. In
\exampleref{CounreachableExample}, we found that concurrent decrements violate
\invariantconfluence{} which led us to a segmentation which prohibited
concurrent decrements. We now propose a new segmentation with escrow amount $k$
that will allow us to perform concurrent decrements that respect the escrowed
value. The first segment $(\setst{(p_1, p_2, p_3), (n_1, n_2, n_3)}{p_1, p_2,
p_3 \geq k \land n_1, n_2, n_3 \leq k}, T)$ allows for concurrent increments
and decrements so long as every $p_i \geq k$ and every $n_i \leq k$.
Intuitively, this segment represents the situation in which every server has
escrowed a value of $k$. Each server can decrement freely, so long as they don't
exceed their escrow budget of $k$. The second segment is the one presented in
\exampleref{CounreachableExample} which prohibits concurrent decrements. We ran
our decision procedure on this example and it concluded that it was segmented
\invariantconfluent{} in less than a tenth of a second and without any human
interaction.
