\section{Invariant Confluence}\seclabel{InvariantConfluence}
Informally, a replicated object is \defword{\invariantconfluent{}} with respect
to an invariant if every replica of the object is guaranteed to satisfy the
invariant despite the possibility of different replicas being concurrently
modified or merged together~\cite{bailis2014coordination}. In this section, we
make this informal notion of \invariantconfluence{} precise.

We begin by introducing our system model of replicated objects in which a
distributed object and accompanying invariant is replicated across a set of
servers. Clients send transactions to servers, and a server executes a
transaction so long as it maintains the invariant. Servers execute
transactions without coordination, but to avoid state divergence, servers
periodically gossip with one another and merge their replicas.
%
After we introduce the system model, we present a formal definition of
\invariantconfluence{}.

\subsection{System Model}

A \defword{distributed object} $O = (S, \join)$ consists of a set $S$ of states
and a binary merge operator $\join: S \times S \to S$ that merges two states
into one. A \defword{transaction} $t: S \to S$ is a function that maps one
state to another. An \defword{invariant} $I$ is a subset of $S$. Notationally,
we write $I(s)$ to denote that $s$ satisfies the invariant (i.e. $s \in I$)
and $\lnot I(s)$ to denote that $s$ does not satisfy the invariant (i.e. $s
\notin I$).

\begin{example}\examplelabel{Ints}
  $O = (\ints, \max)$ is a distributed object consisting of integers merged by the
  $\max$ function; $t(x) = x + 1$ is a transaction that adds one to a state; and
  $\setst{x \in \ints}{x \geq 0}$ is the invariant that states $x$ are
  non-negative.
\end{example}

% Note that by modelling a transaction $t$ as a function $S \to S$, we focus
% exclusively on the effects that a transaction has on the object (i.e.\
% ``writes'' to the object). Transactions are also free to read the value of the
% object, but these reads are not captured by our model because, as we'll see,
% they do not affect \invariantconfluence{}. For example, we could model any
% read-only transaction as a function $t$ where $t(s) = s$ for every $s \in S$.

In our system model, a distributed object $O$ is replicated across a set $p_1,
\ldots, p_n$ of $n$ servers. Each server $p_i$ manages a replica $s_i \in S$ of
the replicated object. Every server begins with a start state $s_0 \in S$, a
fixed set $T$ of transactions, and an invariant $I$. Servers repeatedly perform
one of two actions.

First, a client can contact a server $p_i$ and request that it execute a
transaction $t \in T$. $p_i$ speculatively executes $t$, transitioning from
state $s_i$ to state $t(s_i)$. If $t(s_i)$ satisfies the invariant---i.e.
$I(t(s_i))$---then $p_i$ commits the transaction and remains in state $t(s_i)$.
Otherwise, $p_i$ aborts the transaction and reverts to state $s_i$.

Second, a server $p_i$ can send its state $s_i$ to another server $p_j$ with
state $s_j$ causing $p_j$ to transition from state $s_j$  to state $s_i \join
s_j$. Servers periodically merge states with one another in order to keep their
states loosely synchronized.
% \footnote{%
%   Notably, if $O$ is a CRDT---i.e. $O$ is a semilattice and every transaction
%   $t \in T$ is inflationary---then this periodic merging ensures that $O$ is
%   strongly eventually consistent~\cite{shapiro2011conflict}.
% }.
Note that unlike with transactions, servers \emph{cannot} abort a merge; server
$p_j$ must transition from $s_j$ to $s_i \join s_j$ whether or not $s_i \join
s_j$ satisfies the invariant.

Informally, $O$ is \defword{\invariantconfluent{}} with respect to $s_0$, $T$,
and $I$, abbreviated \defword{\sTIconfluent{}}, if every replica $s_1, \ldots,
s_n$ is guaranteed to always satisfy the invariant $I$ in every possible
execution of the system.

\subsection{Expression-Based Formalism}
To define \invariantconfluence{} formally, we represent a state produced by a
system execution as a simple expression generated by the grammar
\[
  e ::= s \mid t(e) \mid e_1 \join e_2
\]
where $s$ represents a state in $S$ and $t$ represents a transaction in $T$. As
an example, consider the system execution in \figref{SystemExecution} in which
a distributed object is replicated across servers $p_1$, $p_2$, and $p_3$.
Server $p_3$ begins with state $s_0$, transitions to state $s_2$ by executing
transaction $u$, transitions to state $s_5$ by executing transaction $w$, and
then transitions to state $s_7$ by merging with server $p_1$. Similarly, server
$p_1$ ends up with state $s_6$ after executing transactions $t$ and $v$ and
merging with server $p_2$. In \figref{Expression}, we see the abstract syntax
tree of the corresponding expression for state $s_7$.

{\input{figures/invariant_confluence_definitions}}

We say an expression $e$ is \defword{\sTIreachable{}} if it corresponds to a
valid execution of our system model. Formally, we define
$\sTIreachablepredicate{e}$ to be the predicate that satisfies the
following conditions:
\begin{itemize}
  \item
    $\sTIreachablepredicate{s_0}$.
  \item
    For all expressions $e$ and for all transactions $t$ in the set $T$ of
    transactions, if $\sTIreachablepredicate{e}$ and $I(t(e))$, then
    $\sTIreachablepredicate{t(e)}$.
  \item
    For all expressions $e_1$ and $e_2$, if $\sTIreachablepredicate{e_1}$ and
    $\sTIreachablepredicate{e_2}$, then $\sTIreachablepredicate{e_1 \join
    e_2}$.
\end{itemize}
Similarly, we say a state $s \in S$ is \sTIreachable{} if there exists an
\sTIreachable{} expression $e$ that evaluates to $s$. Returning to
\exampleref{Ints} with start state $s_0 = 42$, we see that all integers greater
than or equal to 42 (i.e.\ $\setst{x \in \ints}{x \geq 42}$) are
\sTIreachable{}, and all other integers are \sTIunreachable{}.

Finally, we say $O$ is \defword{\invariantconfluent} with respect to $s_0$,
$T$, and $I$, abbreviated \defword{\sTIconfluent{}}, if all reachable states
satisfy the invariant:
\[
  \setst{s \in S}{\sTIreachablepredicate{s}} \subseteq I
\]
