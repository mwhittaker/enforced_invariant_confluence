\begin{frame}
  \Huge
  \begin{center}
    Goal: develop an invariant-confluence decision procedure.
  \end{center}

  \note{%
    Now that we've defined invariant confluence, we can turn our attention to
    the main goal of our paper. And that is to develop an invariant-confluence
    decision procedure. As you saw in the previos example, determining whether
    or not a distributed object is invariant confluent is not easy to do by
    hand, so we'd like to develop a decision procedure that can automatically
    check whether something is invariant confluent for us.
  }
\end{frame}

\begin{frame}
  \Huge
  \begin{center}
    Reasoning about reachable states is hard.
  \end{center}

  \note{%
    Unfortunately, developing an invariant confluence decision procedure
    straight up is not easy. Invariant confluence is fundamentally a property
    about reachable states but reasoning automatically about reachable states
    is hard.

    Instead of reasoning about invariant confluence directly then, let's look
    at a sufficient condition for invariant confluence called invariant
    closure.
  }
\end{frame}

\begin{frame}
  \Large
  We say a set $S$ is \defword{closed under $f$} if for every $x, y \in S, f(x,
  y) \in S$. \pause For example,
  \begin{itemize}
    \item Even numbers are closed under addition.
    \item Odd numbers are \emph{not} closed under addition.
  \end{itemize}

  \note{%
    First, a quick refresher on what it meas for a set to be closed. We say a
    set $S$ is closed under a binary operator $f$ if for every $x$ and $y$ in
    $S$, $f(x, y)$ is also in $S$. For example, even numbers are closed under
    addition because the sum of any two even numbers is even. But odd numbers
    are not closed under addition because the sum of two odd numbers may not
    be odd.
  }
\end{frame}

\begin{frame}
  \Large
  $O = (S, \join)$ is \defword{\invariantclosed{}} with respect to an invariant
  $I$, abbreviated \defword{\Iclosed{}}, if invariant satisfying states are
  closed under merge. \pause That is, for every state $s_1, s_2 \in S$, if
  $I(s_1)$ and $I(s_2)$, then $I(s_1 \join s_2)$.

  \note{%
    We say that an object $O$ is invariant closed if invariant satisfying
    states are closed under merge. That is, if an object is invariant closed,
    then for every pair of states $s_1$ and $s_2$, if $s_1$ and $s_2$ satisfy
    the invariant then so does $s_1 \join s_2$.
  }
\end{frame}

\begin{frame}
  \Large
  \[
    \text{invariant closure} \implies \text{invariant confluence}
  \]
  \pause
  Transactions perserve invariants. If merging does too, then all reachable
  states satisfy the invariant.

  \note{%
    Invariant closure is a sufficient condition for invariant confluence. Why
    is that? Well for an object to be invariant confluent, every reachable
    state must satisfy the invariant. A state is reachable if it can be reached
    by executing transactions merging states. Transactions are already
    guarnateed to preserve invariants, so if merging is also guaranteed to
    preserve the invariant, then every reachable state always satisfies the
    invariant.
  }
\end{frame}

\begin{frame}
  \Large
  Checking invariant closure is more straightforward.
  \pause
  \begin{align*}
    \forall x_1, & y_1, x_2, y_2.\, \\
    \quad & x_1y_1 \leq 0 \land x_2y_2 \leq 0 \implies \\
    \quad & \max(x_1, x_2)\max(y_1, y_2) \leq 0
  \end{align*}

  \note{%
    The good thing about invariant closure is that it's much easier to check
    automatically. Remember that example we had with pairs of
    integers? We can pose whether or not that object is invariant closed as
    this formula, and we can pass this formula directly to an SMT solver to
    figure out whether it's invariant closed. This is not something we can do
    with invariant confluence because it's hard to express reachability as a
    simple formula like this one.
  }
\end{frame}

\begin{frame}
  \Large
  \[
    \text{invariant closure} \implies \text{invariant confluence}
  \]

  \note{%
    To decide whether an object is invariant confluent, we can take the
    object and ask if it's invariant closed. If it is, then it's also invariant
    confluent and we're done. If it's not invariant closed, then what do we
    know?
  }
\end{frame}

\begin{frame}
  \Large
  \[
    \text{invariant closure}
    \xLeftarrow{\phantom{a}?\phantom{a}}
    \text{invariant confluence}
  \]

  \note{%
    Well, that depends on whether invariant confluence implies invariant
    closure.
  }
\end{frame}

\newcommand{\xmin}{-2}
\newcommand{\xmax}{2}
\newcommand{\ymin}{-2}
\newcommand{\ymax}{2}

% Axes.
\newcommand{\xyaxes}{
  \draw[] (\xmin.5, 0) to (\xmax.5, 0);
  \draw[] (0, \ymin.5) to (0, \ymax.5);
  \node at (\xmax + 1, 0) {$x$};
  \node at (0, \ymax + 1) {$y$};
}

% Quadrant 1.
\newcommand{\quadi}[5]{{
  \newcommand{\argstyle}{#1}
  \newcommand{\argxmin}{#2}
  \newcommand{\argxmax}{#3}
  \newcommand{\argymin}{#4}
  \newcommand{\argymax}{#5}
  \foreach \x in {0, ..., \argxmax} {
    \foreach \y in {0, ..., \argymax} {
      \node[\argstyle] (\x-\y) at (\x, \y) {};
    }
  }
}}

% Quadrant 2.
\newcommand{\quadii}[5]{{
  \newcommand{\argstyle}{#1}
  \newcommand{\argxmin}{#2}
  \newcommand{\argxmax}{#3}
  \newcommand{\argymin}{#4}
  \newcommand{\argymax}{#5}
  \foreach \x in {\argxmin, ..., 0} {
    \foreach \y in {0, ..., \argymax} {
      \node[\argstyle] (\x-\y) at (\x, \y) {};
    }
  }
}}

% Quadrant 3.
\newcommand{\quadiii}[5]{{
  \newcommand{\argstyle}{#1}
  \newcommand{\argxmin}{#2}
  \newcommand{\argxmax}{#3}
  \newcommand{\argymin}{#4}
  \newcommand{\argymax}{#5}
  \foreach \x in {\argxmin, ..., 0} {
    \foreach \y in {\argymin, ..., 0} {
      \node[\argstyle] (\x-\y) at (\x, \y) {};
    }
  }
}}

% Quadrant 4.
\newcommand{\quadiv}[5]{{
  \newcommand{\argstyle}{#1}
  \newcommand{\argxmin}{#2}
  \newcommand{\argxmax}{#3}
  \newcommand{\argymin}{#4}
  \newcommand{\argymax}{#5}
  \foreach \x in {0, ..., \argxmax} {
    \foreach \y in {\argymin, ..., 0} {
      \node[\argstyle] (\x-\y) at (\x, \y) {};
    }
  }
}}

% State labels.
\newcommand{\statelabels}{
  \node[statelabel] at (0, 0) {$s_0$};
  \node[statelabel] at (-1, 1) {$s_1$};
  \node[statelabel] at (1, -1) {$s_2$};
  \node[statelabel] at (1, 1) {$s_3$};
}

\tikzstyle{point}=[shape=circle, fill=flatgray, inner sep=3pt]
\tikzstyle{inv}=[line width=0.75pt, draw=black]
\tikzstyle{pointinv}=[point, inv]
\tikzstyle{invregion}=[rounded corners, fill=flatgreen!50, draw=none]
\tikzstyle{reachableregion}=[rounded corners, fill=flatblue!50, draw=none]
\tikzstyle{statelabel}=[anchor=south west, inner sep=1pt]

\begin{frame}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \centering
      \begin{tikzpicture}[scale=1]
        \begin{scope}
          \clip (\xmin.5, \ymax.5) rectangle (\xmax.5, \ymin.5);
          \draw[invregion] (\xmin.9, \ymax.9) rectangle (0.5, -0.5);
          \draw[invregion] (-0.5, 0.5) rectangle (\xmax.9, \ymin.9);
          \draw (0.5, 0.5) to (0.5, \ymax.5);
          \draw (0.5, 0.5) to (\xmax.5, 0.5);
          \draw (-0.5, -0.5) to (-0.5, \ymin.5);
          \draw (-0.5, -0.5) to (\xmin.5, -0.5);
        \end{scope}

        \xyaxes{}
        \quadi{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadii{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiv{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}
      \end{tikzpicture}

      {\Huge Invariant}
    \end{column}
    \begin{column}{0.5\textwidth}
      \centering
      \begin{tikzpicture}[scale=1]
        \begin{scope}
          \clip (-1, 1) rectangle (\xmax.5, \ymin.5);
          \draw[reachableregion, draw=black] (-0.5, 0.5) rectangle (\xmax.9, \ymin.9);
        \end{scope}

        \xyaxes{}
        \quadi{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiv{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}
      \end{tikzpicture}

      {\Huge Reachable}
    \end{column}
  \end{columns}

  \note{%
    To see if it does, let's revisit the example from before. Recall that in
    this example, our object is invariant confluent. The set of reachable
    states is a subset of the invariant.
  }
\end{frame}

\begin{frame}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \centering
      \begin{tikzpicture}[scale=1]
        \begin{scope}
          \clip (\xmin.5, \ymax.5) rectangle (\xmax.5, \ymin.5);
          \draw[invregion] (\xmin.9, \ymax.9) rectangle (0.5, -0.5);
          \draw[invregion] (-0.5, 0.5) rectangle (\xmax.9, \ymin.9);
          \draw (0.5, 0.5) to (0.5, \ymax.5);
          \draw (0.5, 0.5) to (\xmax.5, 0.5);
          \draw (-0.5, -0.5) to (-0.5, \ymin.5);
          \draw (-0.5, -0.5) to (\xmin.5, -0.5);
        \end{scope}

        \xyaxes{}
        \quadi{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadii{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiv{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}

        \draw[-latex, ultra thick] (-1, 2) to (2, 2);
        \draw[-latex, ultra thick] (2, -1) to (2, 2);
      \end{tikzpicture}

      {\Huge Invariant}
    \end{column}
    \begin{column}{0.5\textwidth}
      \centering
      \begin{tikzpicture}[scale=1]
        \begin{scope}
          \clip (-1, 1) rectangle (\xmax.5, \ymin.5);
          \draw[reachableregion, draw=black] (-0.5, 0.5) rectangle (\xmax.9, \ymin.9);
        \end{scope}

        \xyaxes{}
        \quadi{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiv{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}
      \end{tikzpicture}

      {\Huge Reachable}
    \end{column}
  \end{columns}

  \note{%
    But, note that our object is not invariant closed. The points $(-1, 2)$ and
    $(2, -1)$ both satisfy the invariant, but if we merge them we get the point
    $(2, 2)$, and the point $(2, 2)$ does not satisfy the invariant.
  }
\end{frame}

\begin{frame}
  \Large
  \[
    \text{invariant closure} \centernot\impliedby \text{invariant confluence}
  \]

  \note{%
    Thus, our object is invariant confluent but not invariant closed, so
    invariant confluence does not imply invariant closure. This is unfortunate.
    We can check for invariant closure but not invariant confluence, so we'd
    like the two to be equivalent.

    Are there any situations in which the two do happen to be equivalent?
  }
\end{frame}

\begin{frame}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \centering
      \begin{tikzpicture}[scale=1]
        \begin{scope}
          \clip (\xmin.5, \ymax.5) rectangle (\xmax.5, \ymin.5);
          \draw[invregion] (\xmin.9, \ymax.9) rectangle (0.5, -0.5);
          \draw[invregion] (-0.5, 0.5) rectangle (\xmax.9, \ymin.9);
          \draw (0.5, 0.5) to (0.5, \ymax.5);
          \draw (0.5, 0.5) to (\xmax.5, 0.5);
          \draw (-0.5, -0.5) to (-0.5, \ymin.5);
          \draw (-0.5, -0.5) to (\xmin.5, -0.5);
        \end{scope}

        \xyaxes{}
        \quadi{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadii{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiv{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}

        \draw[-latex, ultra thick] (-1, 2) to (2, 2);
        \draw[-latex, ultra thick] (2, -1) to (2, 2);
      \end{tikzpicture}

      {\Huge Invariant}
    \end{column}
    \begin{column}{0.5\textwidth}
      \centering
      \begin{tikzpicture}[scale=1]
        \begin{scope}
          \clip (-1, 1) rectangle (\xmax.5, \ymin.5);
          \draw[reachableregion, draw=black] (-0.5, 0.5) rectangle (\xmax.9, \ymin.9);
        \end{scope}

        \xyaxes{}
        \quadi{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadii{point}{\xmin}{\xmax}{\ymin}{\ymax}
        \quadiv{pointinv}{\xmin}{\xmax}{\ymin}{\ymax}
      \end{tikzpicture}

      {\Huge Reachable}
    \end{column}
  \end{columns}

  \note{%
    Well, let's take a look at our example again. We noticed that our object is
    not invariant closed because we can merge $(-1, 2)$ and $(2, -1)$ to
    violate the invariant. But, notice that the point $(-1, 2)$ is not
    reachable.
  }
\end{frame}

\begin{frame}
  \Large
  If $I$ is a subset of reachable states, then
  \[
    \text{invariant closure} \iff \text{invariant confluence}
  \]
  \pause
  \begin{itemize}
    \item
      Forward direction: same as before.
    \item
      Backward direction: $I$ is equal to the set of reachable states.
      Reachable states are closed under merge, so so is $I$.
  \end{itemize}

  \note{%
    Turns out, this is not a coincidence. An invariant confluent object may not
    be invariant closed but only because we're merging points that are
    unreachable. If the invariant is a subset of the reachable states---that
    is, if every invariant satisfying point is reachable---then invariant
    closure and invariant confluence are equivalent. \\[12pt]

    Why? Well, the forward direction here is what we proved before. For the
    backwards direction, we have that the invariant is a subset of the set of
    reachable points, and because our object is invariant confluent, the set of
    reachable points is a subset of the invariant. So the invariant and the set
    of reachable points are the same. The set of reachable states is closed
    under merge, so the invariant is also, so the object is invariant closed.
    \\[12pt]

    I know I've walked through a lot of theory pretty quickly, but if you
    remember one slide, remember this one. If the invariant is a subset of the
    reachable states, then invariant closure and invariant confluence are
    equivalent. \\[12pt]
  }
\end{frame}
