\section{Merge Reduction}\seclabel{MergeReduction}
In \secref{InvariantClosure}, we discussed how invariant-closure is
fundamentally a property of reachability and that invariant-closure is
sufficient but not necessary for invariant-confluence because it fails to
incorporate any notion of reachability. Using this intuition, we established
\thmref{IclosureEquivalentIconfluence} and then exploited the theorem in
\algoref{InteractiveDecisionProcedure}. In this section, we again take
advantage of this intuition to develop a new sufficient condition for
invariant-confluence that can be checked without user interaction and that
covers some cases not covered by invariant-closure.

An expression $e = t_1(t_2(\ldots(t_n(s))\ldots))$ is \defword{merge-free} if
does not contain any merges (i.e.\ it is generated by the grammar $e ::= s \mid
t(e)$). An object $O = (S, \join)$ is \defword{merge-reducible} with respect to
a start state $s_0 \in S$, a set of transactions $T$, and an invariant $I$,
abbreviated \defword{\sTImergereducible}, if for every pair of $e_1$ and $e_2$
of merge-free $\sTIreachable{}$ expressions, there exists some merge-free
$\sTIreachable{}$ expression $e_3$ that evaluates to the same state as $e_1
\join e_2$. Intuitively, if $O$ is merge-reducible, we can replace $e_1 \join
e_2$ (which has one merge) with $e_3$ (which has no merges) to obtain an
equivalent expression with fewer merges.

\begin{theorem}\thmlabel{ReducibilityImpliesIconfluence}
  Given an object $O = (S, \join)$, a start state $s_0 \in S$, a set of
  transactions $T$, and an invariant $I$, if $I(s_0)$ and if $O$ is
  \sTImergereducible{}, then $O$ is \sTIconfluent{}.
\end{theorem}

The proof of \thmref{ReducibilityImpliesIconfluence} is a straightforward
induction. We begin with an $\sTIreachable{}$ expression $e$ and repeatedly
replace any subexpression that merges two merge-free subexpressions with an
equivalent merge-free reachable subexpression (which we can do because $O$ is
merge-reducible). We repeat this process until $e$ has been completely replaced
with an equivalent merge-free reachable expression $e'$. Because $I(s_0)$ and
because our system model only executes transactions that preserve the
invariant, $e'$ (and hence $e$) is guaranteed to satisfy the invariant. Thus,
all reachable states satisfy the invariant, so $O$ is invariant-confluent.

Merge-reducibility is a sufficient condition for invariant-confluence, but
unlike with invariant-closure, it is not straightforward to automatically
determine if an object is merge-reducible. In \thmref{LatticeProperty}, we
outline a sufficient condition for merge-reducibility that is straightforward
to determine automatically.

\begin{theorem}\thmlabel{LatticeProperty}
  Given an object $O = (S, \join)$, a start state $s_0 \in S$, a set of
  transactions $T$, and an invariant $I$, if the following criteria are met,
  then $O$ is \sTIconfluent{}.
  \begin{enumerate}
    \item
      $O$ is a semilattice.

    \item
      For every $t \in T$, there exists some $s_t \in S$ such that for all $s
      \in S$, $t(s) = s \join s_t$. That is, every transaction $t$ is of the
      form $t(s) = s \join s_t$ for some constant $s_t$.

    \item
      For every pair of transactions $t_1, t_2 \in T$ and for all states $s \in
      S$, if $I(s)$, $I(t_1(s))$, and $I(t_2(s))$, then $I(t_1(s) \join
      t_2(s))$.

    \item
      $I(s_0)$.
  \end{enumerate}
\end{theorem}

% interactive is nice but requires user feedback; here we develop an alternate suff cond; to do so we introduce blah blah elimination
% merge elimination
% new sufficient condition
% example showing they're not equivalnet
% some discussion taht it's general
