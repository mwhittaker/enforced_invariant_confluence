\section{Invariant-Confluence}
Informally, a replicated object is \defword{invariant-confluent} with respect
to an invariant if every replica of the object is guaranteed to satisfy the
invariant despite the possibility of different replicas being concurrently
modified or merged together~\cite{bailis2014coordination}. In this section, we
make this informal notion of invariant-confluence precise. We begin by
introducing our system model of replicated objects and then present a formal
definition of invariant-confluence.

A \defword{distributed object} $O = (S, \join)$ consists of a set $S$ of
states and a binary merge operator $\join: S \times S \to S$ which merges two
states into one. A \defword{transaction} $t: S \to S$ is a function which maps
one state to another. An \defword{invariant} $I$ is a subset of $S$.
Notationally, we write $I(s)$ to denote that $s$ satisfies the invariant (i.e.
$s \in I$) and $\lnot I(s)$ to denote that $s$ does not satisfy the invariant
(i.e. $s \notin I$).
%
For example, $O = (\ints, +)$ is a distributed object consisting of integers
merged by addition; $t(x) = x + 1$ is a transaction which adds one to a state;
and $\setst{x \in \ints}{x \geq 0}$ is the invariant that states $x$ are
non-negative.

In our system model, a distributed object $O$ is replicated across a set $p_1,
\ldots, p_n$ of $n$ servers. Each server $p_i$ manages a replica $s_i \in S$ of
the replicated object. Every server begins with a start state $s_0 \in S$, a
fixed set $T$ of transactions, and an invariant $I$. Servers can perform one of
two actions.

First, a client can contact a server $p_i$ and request that it execute a
transaction $t \in T$. $p_i$ speculatively executes $t$ transitioning from
state $s_i$ to state $t(s_i)$. If $t(s_i)$ satisfies the invariant---i.e.
$I(t(s_i))$---then $p_i$ commits the transaction and remains in state $t(s_i)$.
Otherwise, $p_i$ aborts the transaction and reverts to state $s_i$.

Second, a server $p_i$ can sent its state $s_i$ to another server $p_j$ with
state $s_j$ causing $p_j$ to transition from state $s_j$  to state $s_i \join
s_j$. Servers periodically merge states with one another in order to keep their
states loosely synchronized\footnote{%
  Notably, if $O$ is a CRDT---i.e. $O$ is a semilattice and every transaction
  $t \in T$ is inflationary---then this periodic merging ensures that $O$ is
  strongly eventually consistent~\cite{shapiro2011conflict}.
}.
Note that unlike with transactions, servers \emph{cannot} abort a merge; server
$p_j$ must transition from $s_j$ to $s_i \join s_j$ whether or not $s_i \join
s_j$ satisfies the invariant.

Informally, $O$ is \defword{invariant-confluent with respect to $s_0$, $T$, and
$I$}, abbreviated \defword{\sTIconfluent{}} if every replica $s_1, \ldots, s_n$
is guaranteed to always satisfy the invariant $I$ in every possible execution
of the system.

To define invariant-confluence formally, we represent a state produced by a
system execution as a simple expression generated by the grammar
\[
  e ::= s \mid t(e) \mid e_1 \join e_2
\]
where $s$ represents a state in $S$ and $t$ represents a transaction in $T$. As
an example, consider the system execution in \figref{SystemExecution} in which
a distributed object is replicated across servers $p_1$, $p_2$, and $p_3$.
Server $p_3$ begins with state $s_0$, transitions to state $s_2$ by executing
transaction $u$, transitions to state $s_5$ by executing transaction $w$, and
then transitions to state $s_7$ by merging with server $p_1$. Similarly, server
$p_1$ ends up with state $s_6$ after executing transactions $t$ and $v$ and
merging with server $p_2$. In \figref{Expression}, we see the abstract syntax
tree of the corresponding expression.

{\input{figures/invariant_confluence_definitions}}

% - define invariant confluence
%   - define system model
%   - define expression based system model
%   - define invariant confluence
%   - Give example with two integers

% TODO: Give a footnote about the difference between this definition and the original definition.
