\section{Segmented Invariant-Confluence}\seclabel{SegmentedInvariantConfluence}
If a distributed object is invariant-confluent, then the object can be
replicated without the need for any form of coordination to maintain the
object's invariant. But what if the object is \emph{not} invariant-confluent?
In this section, we present a generalization of invariant-confluence called
\defword{segmented invariant-confluence} that can be used to maintain the
invariants of non-invariant-confluent objects, requiring only a small amount of
coordination.

The main idea behind segmented invariant-confluence is to segment the state
space into a number of segments and restrict the set of allowable transactions
within each segment in such a way that the object is invariant-confluent
\emph{within each segment} (even though it may not be globally
invariant-confluent). Then, servers can run coordination-free within a segment
and need only coordinate when transitioning from one segment to another. We now
formalize this idea by defining segmented invariant-confluence and a new system
model to execute segmented invariant-confluent objects.

\subsection{Formalism}
Consider a distributed object $O = (S, \join)$, a start state $s_0 \in S$, a
set of transitions $T$, and an invariant $I$. A segmentation $\Sigma = (I_1,
T_1), \ldots, (I_n, T_n)$ is a sequence (not a set) of $n$ segments$(I_i, T_i)$
where every $T_i$ is a subset of $T$. $O$ is \defword{segmented
invariant-confluent} with respect to $s_0$, $T$, $I$, and $\Sigma$, abbreviated
\defword{\sTISconfluent}, if the following conditions hold:
\begin{itemize}
  \item
    The start state satisfies the invariant (i.e. $I(s_0)$).

  \item
    $I$ is covered by the invariants in $\Sigma$ (i.e. $I = \cup_{i=1}^n I_i$).
    Note that invariants in $\Sigma$ do \emph{not} have to be disjoint. Thus,
    they do not have to partition $I$; they just have to cover $I$.

  \item
    For every $(I_i, T_i) \in \Sigma$ and for every state $s \in I_i$, $O$ is
    \sticonfluent{s}{T_i}{I_i}.
\end{itemize}

{\input{figures/segmented_z2}}

\begin{example}\examplelabel{SegmentedZ2}
  Consider again the object $O = (\ints \times \ints, \join)$, transactions $T
  = \set{t_{x+1}, t_{y-1}}$, and invariant $I = \setst{(x, y)}{xy \leq 0}$ from
  \exampleref{Z2}, but now let the start state $s_0$ be $(-42, 42)$. $O$ is
  \emph{not} \sTISconfluent{} because the points $(0, 42)$ and $(42, 0)$ are
  reachable, and merging these points yields $(42, 42)$ which violates the
  invariant. However, $O$ is \sTISconfluent{} for $\Sigma = (I_1, T_1)$, $(I_2,
  T_2)$, $(I_3, T_3)$, $(I_4, T_4)$ where
  \begin{align*}
    I_1 &= \setst{(x, y)}{x < 0, y > 0}       &T_1 &= \set{t_{x+1}, t_{y-1}} \\
    I_2 &= \setst{(x, y)}{x \geq 0, y \leq 0} &T_2 &= \set{t_{x+1}, t_{y-1}} \\
    I_3 &= \setst{(x, y)}{x = 0}              &T_3 &= \set{t_{y-1}} \\
    I_4 &= \setst{(x, y)}{y = 0}              &T_4 &= \set{t_{x+1}}
  \end{align*}
  $\Sigma$ is illustrated in \figref{SegmentedZ2}. Clearly, $s_0$ satisfies the
  invariant, and $I_1, I_2, I_3, I_4$ cover $I$. Moreover, for every $(I_i,
  T_i) \in \Sigma$, we see that $O$ is \iclosed{I_i}, so $O$ is
  \sticonfluent{s}{T_i}{I_I} for every $s \in I_i$. Thus, $O$ is
  \sTISconfluent{}.
\end{example}

\subsection{System Model}
Now, we describe a new system model used to replicate a segmented
invariant-confluent object with coordination-free execution within a segment
and a small amount of coordination to transition between segments. As before,
we replicate an object $O$ across a set $p_1, \ldots, p_n$ of $n$ servers each
of which manages a replica $s_i \in S$ of the object. Every server begins with
$s_0$, $T$, $I$, and $\Sigma$. Moreover, at any given point in time, a server
designates one of the segments in $\Sigma$ as its \defword{active segment}.
Initially, every server chooses the first segment $(I_i, T_i) \in \Sigma$ such
that $I_i(s_0)$ to be its active segment. We'll see momentarily the
significance of the active segment.

As before, servers repeatedly perform one of two actions: execute a transaction
or merge states with another server. Merging states in the new system model is
identical to merging states in the old system model. A server $p_i$ sends its
state $s_i$ to another server $p_j$ which \emph{must} merge $s_i$ into its
state $s_j$.
%
Transaction execution in the new system model, on the other hand, is a bit more
involved. Consider a server $s_i$ with active segment $(I_i, T_i)$. A client
can request that $p_i$ execute a transaction $t \in T$. We consider what
happens when $t \in T_i$ and $t \notin T_i$ separately.

If $t \notin T_i$, then $p_i$ initiates a round of global coordination to
execute $t$. During global coordination, every server temporarily stops
processing and transitions to state $s = s_1 \join \ldots \join s_n$, the join
of every server's state. Then, every server speculatively executes $t$
transitioning to state $t(s)$. If $t(s)$ violates the invariant (i.e.  $\lnot
I(t(s))$), then every server aborts $t$ and reverts to state $s$.  Then, $p_i$
replies to the client. If $t(s)$ satisfies the invariant (i.e. $I(t(s))$), then
every server commits $t$ and remains in state $t(s)$. Every server then chooses
the first segment $(I_i, T_i) \in \Sigma$ such that $I_i(t(s))$ to be the new
active segment. Note that such a segment is guaranteed to exist because the
segment invariants cover $I$. Moreover, $\Sigma$ is ordered, so every server
will deterministically pick the same active segment. In fact, an invariant of
the system model is that at any given point of normal processing, every server
has the same active segment.

$t \in T_i$, then $p_i$ executes $t$ immediately and without coordination. If
$t(s_i)$ satisfies the \emph{active} invariant (i.e. $I_i(t(s_i))$), then $p_i$
commits $t$, stays in state $t(s_0)$, and replies to the client. If $t(s_i)$
violates the invariant (i.e.  $i.e. \lnot I(t(s_i))$), then $p_i$ aborts $t$,
reverts to state $s_i$, and replies to the client. If $t(s_i)$ satisfies the
invariant but violates the active invariant (i.e. $I(t(s_i))$ but $\lnot
I_i(t(s_i))$), then $p_i$ reverts to state $s_i$ and initiates a round of
global coordination to execute $t$, as described in the previous paragraph.
Transaction execution is summarized in \algoref{TxnExecution}.

\begin{algorithm}[t]
  \caption{Transaction execution in new system model}%
  \algolabel{TxnExecution}
  \begin{algorithmic}
    \If{$t \notin T_i$}
      \State Execute $t$ with global coordination
    \Else{}
      \If{$I_i(t(s_i))$} Commit $t$
      \ElsIf{$\lnot I(t(s_i))$} Abort $t$
      \Else{} Execute $t$ with global coordination
      \EndIf{}
    \EndIf{}
  \end{algorithmic}
\end{algorithm}

This system model guarantees that all replicas of a segmented
invariant-confluent object always satisfy the invariant. All servers begin in
the same initial state and with the same active segment. Thus, because $O$ is
invariant-confluent with respect to every segment, servers can execute
transactions within the active segment without any coordination and guarantee
that the invariant is never violated. Any operation that would violate the
assumptions of invariant-confluence system model (e.g.\ executing a transaction
that's not permitted in the active segment or executing a permitted transaction
that leads to a state outside the active segment) triggers a global
coordination. Globally coordinated transactions are only executed if they
maintain the invariant. Moreover, if a globally coordinated transaction leads
to another segment, the coordination ensures that all servers begin in the same
start state and with the same active replica, reestablishing the assumptions of
the invariant-confluence system model.

\subsection{Discussion}
There are a couple of things worth noting about segmented invariant-confluence
and its system model. First, invariant-confluence is a very coarse-grained
property. If an object is invariant-confluent, then we can replicate it with no
coordination. If it is not invariant-confluent, then we have no guarantees.
There's no in-between. Segmented invariant-confluence, on the other hand, is a
much more fine-grained property that can be applied to applications with
varying degrees of complexity.  Segmented invariant-confluence provides
guarantees to complex applications that require a large number of segments and
to simple applications with a smaller number of segments, whereas
invariant-confluence only provides guarantees to applications that can be
segmented into a single segment.

Second, segmented invariant-confluence can naturally model distributed locking.
One approach to replicating non-invariant-confluent objects is to recognize
which transactions cannot be safely executed concurrently and then require them
to acquire a distributed lock before executing~\cite{balegas2015putting,
gotsman2016cause}. For example, in a banking application with the invariant
that all balances remain positive, concurrent deposits are permitted, but
concurrent withdrawals can lead to invariant violations, thus forcing
withdrawals to first acquire a distributed lock before executing. To model this
locking with segmented invariant-confluence, we simply remove lock-acquiring
transactions from every segment's set of transactions. Consequently, executing
these transactions are executed with global coordination, achieving the same
effect as acquiring a distributed lock. In fact, segmented invariant-confluence
can be used to model more fine-grained locking. Omitting a transaction from
only certain segments is analogous to requiring a transaction to acquire a
distributed lock only when certain conditions are met.

% TODO: Forward reference examples in the evaluation section.

Third, we can integrate a couple of optimizations into our system model to
further reduce the amount of coordination required. First, if a server with
state $s_i$ and active segment $(I_i, T_i)$ receives a transaction $t \in I_i$
to execute, and $t(s_i)$ violates the active invariant but not the global
invariant, instead of initiating a round of global coordination, $p_i$ can
simply buffer $t$ for re-execution at a later time. While this increases the
latency required to execute $t$, it's possible that after other transactions
are executed, re-executing $t$ may lead to a state that either satisfies the
active invariant or violates the global invariant. In either case, a round of
global coordination is avoided. Similarly, servers can buffer transactions that
require global coordination, executing an entire batch of these transactions
during a single round of global coordination.
