\section{Invariant-Confluence}

In this section, we present six different ways to think about
invariant-confluence: three state-based approaches and three operation-based
approaches.

\subsection{State-Based}
\begin{definition}
  A \defword{distributed state-based object} $O$ is a pair $(S, \join)$ where
  $S$ is a set of states, and $\join: S \times S \to S$ is a binary merge
  operator that we call join.
\end{definition}

The notion of state-based objects is taken from~\cite{shapiro2011conflict}.
Note that $\join$ is an \emph{arbitrary} function. It does not necessarily have
to satisfy any special properties like associativity or commutativity.

\begin{definition}
  A \defword{state-based transaction} $t: S \to S$ is a function that maps one
  state to another.
\end{definition}

\begin{definition}
  An \defword{invariant} $I \subseteq S$ is a subset of states. Notationally,
  we say $I(s)$ to mean $s \in I$ and $\lnot I(s)$ to mean $s \notin I$.
\end{definition}

We formalize an invariant as a set of states, but we can also think of a
predicate as a formula over states. For example, we can think of the invariant
$\setst{(x, y) \in \ints \times \ints}{x \geq y}$ as the formula $x \geq y$ and
vice-versa.

\begin{example}
  $(\nats, +)$ is a distributed object, $t(x) = 2x$ is a transaction, and
  $\setst{x \in \nats}{\text{$x$ is even}}$ is an invariant. Here, $I(0)$ and
  $I(2)$ but $\lnot I(1)$ and $\lnot I(3)$.
\end{example}

There are three ways to think about state-based invariant-confluence: a
process-based approach, a graph-based approach, and an expression-based
approach. Below, we describe the process-based approach and the graph-based
approach informally and describe the expression-based approach formally. All
three approaches are illustrated in \figref{StateBasedModels}.

\input{figs/statebased_iconfluence.fig}

\subsubsection{Process-Based}
The process-based model is most similar to the process model described by
Shapiro et al.\ in~\cite{shapiro2011conflict}. We are given a state-based
object $O = (S, \join)$, a start state $s_0 \in S$, a set of transactions $T$,
an invariant $I$, and a set $\seq{p}{1}{n}$ of $n$ processors. Each processor
begins with state $s_0$. A processor $p_i$ can perform one of two actions.

\begin{itemize}
  \item
    $p_i$ can execute a transaction $t \in T$ to transition from state $s$ to
    state $t(s)$, given that $I(t(s))$. If $\lnot I(t(s))$, then $p_i$ will not
    execute $t$ (or it will execute $t$ but then abort it; think of it however
    you like).

  \item
    $p_i$ can send its state $s_i$ to another processor $p_j$ with state $s_j$
    causing $p_j$ to transition from state $s_j$ to state $s_i \join s_j$ (or
    $s_j \join s_i$; it doesn't really matter). Note that unlike executing a
    transaction, $p_j$ must transition from $s_j$ to $s_i \join s_j$ even if
    $\lnot I(s_i \join s_j)$.
\end{itemize}

$O$ is invariant-confluent with respect to $s_0$, $T$, and $I$ (abbreviated $O$
is \sTIconfluent{}) if every reachable state (including $s_0$) satisfies the
invariant. Note that this definition of invariant-confluence is different from
the original definition in~\cite{bailis2014coordination}. Later, we will see
that they are equivalent.

\subsubsection{Graph-Based}
The graph-based approach is most similar to the model used by Bailis et al.\
in~\cite{bailis2014coordination}. We are given a directed acyclic graph where
vertices are states, and edges are either labelled with transactions or are
unlabelled if they correspond to a join. The graph is really just an alternate
way of representing an execution in the process-based model, but with duplicate
states collapsed into a single vertex. As with the process-based model, we say
that $O$ is \sTIconfluent{} if every vertex in every graph satisfies the
invariant.

\subsubsection{Expression-Based}
The expression-based approach formalizes the process-based and graph-based
approach using expressions. Given a state based object $O = (S, \join)$ and a
set of transactions $T$, we consider expressions generated by the following
grammar:
\[
  e ::= s \mid t(e) \mid e_1 \join e_2
\]
where $s$ correspond to a state in $S$ and $t$ corresponds to a transaction in
$T$. We can evaluate an expression $e$, written $eval(e)$, in the obvious way:
\begin{mathpar}
  eval(s) \defeq s

  eval(t(e)) \defeq t(eval(e))

  eval(e_1 \join e_2) \defeq eval(e_1) \join eval(e_2)
\end{mathpar}

\begin{definition}
  An expression $e$ \defword{satisfies $I$}, denoted $I(e)$, if $I(eval(e))$.
\end{definition}

\begin{definition}
  We say an expression is \defword{$\sTIreachable{}$} if it can be reached in
  an execution of the process-based model with starting state $s_0$,
  transactions $T$, and invariant $I$. Formally, we defined a predicate
  $\sTIreachable{}$ as follows:

  \begin{mathpar}
    \inferrule{ }{\sTIreachable{s_0}}

    \inferrule{\sTIreachable{e} \\ t \in T \\ I(t(e))}{\sTIreachable{t(e})}

    \inferrule{\sTIreachable{e_1} \\ \sTIreachable{e_2}}
              {\sTIreachable{e_1 \join e_2}}
  \end{mathpar}

  We say a state us $\sTIreachable{}$ if there exists an $\sTIreachable{}$
  expression $e$ such that $eval(e) = s$.
\end{definition}

\begin{definition}
  $O$ is \defword{\sTIconfluent{}} if $\setst{s}{\sTIreachable{s}} \subseteq
  I$. In other words, $T$ is \sTIconfluent{} if all $\sTIreachable{}$ states
  satisfy the invariant.
\end{definition}

As we mentioned earlier, this definition of \sTIconfluence{} is different than
the original definition presented in~\cite{bailis2014coordination} (though it
is the same as the definition in~\cite{gotsman2016cause}), but they are
(almost) equivalent. We introduce some definitions and then prove this.

\begin{definition}
  An expression $e$ \defword{recursively satisfies $I$}, denoted $\Irec{e}$, if
  $e$ and all of $e$'s children satisfy $I$. That is,
  \begin{mathpar}
    \inferrule{I(s)}{\Irec{s}}

    \inferrule{I(t(e)) \\ \Irec{e}}{\Irec{t(e)}}

    \inferrule{I(e_1 \join e_2) \\ \Irec{e_1} \\ \Irec{e_2}}
              {\Irec{e_1 \join e_2}}
  \end{mathpar}
\end{definition}

Bailis et al.\ defined \sTIconfluence{} to mean that all $\sTIreachable{}$
expressions recursively satisfying $I$ are closed under join. That is, $O$ is
\sTIconfluent{} if
\[
  \forall e_1, e_2 \in \setst{e}{\sTIreachable{e}}.\;
    \Irec{e_1} \land \Irec{e_2} \implies I(e_1 \join e_2)
\]
If $\lnot I(s_0)$, then invariant-confluence holds vacuously which is a bit
silly, so Bailis et al.\ probably ought to have also added the condition
$I(s_0)$ to their definition of invariant-confluence. Doing so, the two
definitions become equivalent.

\begin{claim}\clmlabel{StateBasedTwoIconfluenceDefs}
  Consider a state based object $O = (S, \join)$, a start state $s_0$, a set of
  transactions $T$, and an invariant $I$. The following two are equivalent:
  \begin{enumerate}[\quad(1)]
    \item
      $\setst{s}{\sTIreachable{s}} \subseteq I$

    \item
      $I(s_0)$ and
      $\forall e_1, e_2 \in \setst{e}{\sTIreachable{e}}.\;
         \Irec{e_1} \land \Irec{e_2} \implies I(e_1 \join e_2)$
  \end{enumerate}
\end{claim}
\begin{elidableproof}
  First, we show that (1) implies (2). Axiomatically, $\sTIreachable{s_0}$, so
  by (1), $I(s_0)$. Let $e_1$ and $e_2$ be arbitrary $\sTIreachable{}$
  expressions. Let $s_1 = eval(e_1)$ and $s_2 = eval(e_2)$. $e_1 \join e_2$ is
  $\sTIreachable{}$, so $s_1 \join s_2$ is $\sTIreachable{}$, so by (1), $I(s_1
  \join s_2)$, so $I(e_1 \join e_2)$.

  Next, we show that (2) implies (1). We prove by structural induction that for
  all $e$, $\sTIreachable{e} \implies \Irec{e}$. From this, (1) is immediate.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      $I(s_0)$ by (2), so $\Irec{s_0}$

    \item \textbf{Case $t(e)$.}
      Let $t(e)$ be $\sTIreachable{}$. Then, $\sTIreachable{e}$ and $I(t(e))$.
      By the inductive hypothesis, $\Irec{e}$, so by the definition of
      $\Irec{\cdot}$, $\Irec{t(e)}$.

    \item \textbf{Case $e_1 \join e_2$.}
      Let $e_1 \join e_2$ be $\sTIreachable{}$. Then, $\sTIreachable{e_1}$ and
      $\sTIreachable{e_2}$.  By the inductive hypothesis, $\Irec{e_1}$ and
      $\Irec{e_2}$. By $(2)$, $I(e_1 \join e_2)$. Thus, by the definition of
      $\Irec{\cdot}$, $\Irec{e_1 \join e_2}$.
  \end{itemize}
\end{elidableproof}

\subsection{Operation-Based}
\begin{definition}
  A \defword{distributed operation-based object} is a set $O = S$ of states.
\end{definition}

Like state-based objects, the notion of operation-based objects is taken
from~\cite{shapiro2011conflict}. Note that we do not have a join function like
we did with state-based objects.

\begin{definition}
  An \defword{operation-based transaction} $t: S \to (S \to S)$ is a function
  that maps a state to a \defword{shadow transaction} $t(s): S \to S$. The term
  shadow transaction is taken from~\cite{li2014automating}.
\end{definition}

The definition of an invariant is the same in the state-based and
operation-based model.

\begin{example}
  $\nats$ is a distributed operation-based object. $t(x) = \lambda y.\ x + y$
  is a transaction that given a state $x$ returns a function $\lambda y.\ x +
  y$ that adds $x$ to its argument. $\setst{x \in \nats}{x \geq 0}$ is an
  invariant.
\end{example}

As with state-based objects, there are three ways to think about
operation-based invariant-confluence: a process-based approach, a graph-based
approach, and an expression-based approach. All three approaches are
illustrated in \figref{OpBasedModels} and are described in more detail below.

\input{figs/opbased_iconfluence.fig}

\subsubsection{Process-Based}
As with the state-based approach, the process-based model is most similar to
the process model described by Shapiro et al.\ in~\cite{shapiro2011conflict}.
We are given an operation-based object $O$, a start state $s_0$, a set of
transactions $T$, an invariant $I$, and a set $\seq{p}{1}{n}$ of $n$
processors. Each processors begins with state $s_0$. A processor $p_i$ can do
one of two things.

\begin{itemize}
  \item
    $p_i$ can execute a transaction $t$ on its current state $s$ and then
    transitions from state $s$ to state $t(s)(s)$, given that $I(t(s)(s))$. If
    $\lnot I(t(s)(s))$, then $p_i$ will not perform $t$. If $p_i$ does execute
    $t$, then it broadcasts $t(s)$ to all other processors exactly once.

  \item
    $p_i$ can receive a broadcast shadow transaction $t(s_j)$ from some other
    processor $p_j$. When $p_i$ receives $t(s_j)$, it transitions from its
    state $s_i$ to state $t(s_j)(s_i)$. When $p_i$ receives a shadow
    transaction, it must execute it, even if $\lnot I(t(s_j)(s_i))$.
\end{itemize}

$O$ is \sTIconfluent{} if every reachable state (including $s_0$) satisfies the
invariant.

\subsubsection{Graph-Based}
In the graph-based model, we are given a directed acyclic graph in which each
vertex is a state $s$ and each edge is labelled with a shadow operation $t(s)$
where $s$ is some other vertex in the graph. $(O, T)$ is \sTIconfluent{} if
every vertex in every graph satisfies $I$.

\subsubsection{Expression-Based}
Given an operation-based object $O = S$ and a set of transactions $T$, we
consider expressions built from the following grammar:
\[
  e ::= s \mid t(e_1)(e_2)
\]
where $s$ corresponds to a state in $S$ and $t$ corresponds to a transaction in
$T$. We can evaluate an expression, denoted $eval(e)$, in the obvious way:
\begin{mathpar}
  eval(s) \defeq s

  eval(t(e_1)(e_2)) \defeq t(eval(e_1))(eval(e_2))
\end{mathpar}

\begin{definition}
  An expression $e$ \defword{satisfies $I$}, denoted $I(e)$, if $I(eval(e))$.
\end{definition}

\begin{definition}
  As with state-based expressions, we formalize which operation-based
  expressions are $\sTIreachable{}$.

  \begin{mathpar}
    \inferrule{ }{\sTIreachable{s_0}}

    \inferrule{
      \sTIreachable{e_1} \\
      \sTIreachable{e_2} \\
      t \in T \\
      I(t(e_1)(e_1))
    }{\sTIreachable{t(e_1)(e_2)}}
  \end{mathpar}

  Similarly, a state $s$ is $\sTIreachable{}$ if there exists an
  $\sTIreachable{}$ expression $e$ such that $eval(e) = s$.
\end{definition}

\begin{definition}
  $O$ is \defword{\sTIconfluent{}} if $\setst{s}{\sTIreachable{s}} \subseteq I$.
\end{definition}

As with state-based objects, we have an equivalent definition of
\sTIconfluence{} that deals with the closure of recursively invariant
satisfying states that are $\sTIreachable{}$.

\begin{definition}
  An expression \defword{recursively satisfies $I$}, denoted $\Irec{e}$, if $e$
  and all of $e$'s children satisfy $I$. That is,
  \begin{mathpar}
    \inferrule{I(s_0)}{\Irec{s_0}}

    \inferrule{I(t(e_1)(e_2)) \\ \Irec{e_1} \\ \Irec{e_2}}{\Irec{t(e_1)(e_2)}}
  \end{mathpar}
\end{definition}

\begin{claim}\clmlabel{OpBasedTwoIconfluenceDefs}
  Given an operation-based object $O = S$, a start sate $s_0$, a set of
  transactions $T$, and an invariant $I$, the following two are equivalent:
  \begin{enumerate}[\quad(1)]
    \item
      $\setst{s}{\sTIreachable{s}} \subseteq I$

    \item
      $I(s_0)$ and
      $\forall e_1, e_2 \in \setst{e}{\sTIreachable{e}}.\;
       \forall t \in T.\;
        \Irec{e_1} \land \Irec{e_2} \land I(t(e_1)(e_1)) \implies
        I(t(e_1)(e_2))$.
  \end{enumerate}
\end{claim}
\begin{elidableproof}
  First, we show that (1) implies (2). $\sTIreachable{s_0}$, so by (1),
  $I(s_0)$. Let $e_1$ and $e_2$ be arbitrary $\sTIreachable{}$ expressions and
  $t$ be an arbitrary transaction in $T$ such that $\Irec{e_1}$, $\Irec{e_2}$,
  and $I(t(e_1)(e_1))$. Let $s_1 = eval(e_1)$ and $s_2 = eval(e_2)$.
  $\sTIreachable{t(e_1)(e_2)}$, so $\sTIreachable{t(s_1)(s_2)}$, so by (1),
  $I(t(s_1)(s_2))$, so $I(t(e_1)(e_2))$.

  Next, we show that (2) implies (1). We show by structural induction that for
  all $e$, $\sTIreachable{e} \implies \Irec{e}$. From this, (1) is immediate.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      By (2), $I(s_0)$, so $\Irec{s_0}$.

    \item \textbf{Case $t(e_1)(e_2)$.}
      Let $t(e_1)(e_2)$ be $\sTIreachable{}$. Then, $\sTIreachable{e_1}$,
      $\sTIreachable{e_2}$, and $I(t(e_1)(e_1))$. By the inductive hypothesis,
      $\Irec{e_1}$ and $\Irec{e_2}$. By (2), $I(t(e_1)(e_2))$, so
      $\Irec{t(e_1)(e_2)}$.
  \end{itemize}
\end{elidableproof}
