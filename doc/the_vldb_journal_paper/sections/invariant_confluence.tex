\section{Invariant Confluence}\seclabel{InvariantConfluence}
Informally, a replicated object is \defword{\invariantconfluent{}} with respect
to an invariant if every replica of the object is guaranteed to satisfy the
invariant despite the possibility of different replicas being concurrently
modified or merged together~\cite{bailis2014coordination}. In this section, we
make this informal notion of \invariantconfluence{} precise.

We begin by introducing our system model of replicated objects in which a
distributed object and accompanying invariant is replicated across a set of
servers. Clients send transactions to servers, and a server executes a
transaction so long as it maintains the invariant. Servers execute
transactions without coordination, but to avoid state divergence, servers
periodically gossip with one another and merge their replicas.
%
After we introduce the system model, we present a formal definition of
\invariantconfluence{}.

\subsection{System Model}

A \defword{distributed object} $O = (S, \join)$ consists of a set $S$ of states
and a binary merge operator $\join: S \times S \to S$ that merges two states
into one. A \defword{transaction} $t: S \to S$ is a
function that maps one state to another. An \defword{invariant} $I$ is a subset
of $S$. Notationally, we write $I(s)$ to denote that $s$ satisfies the
invariant (i.e. $s \in I$) and $\lnot I(s)$ to denote that $s$ does not satisfy
the invariant (i.e. $s \notin I$).

\begin{example}\examplelabel{Ints}
  $O = (\ints, \max)$ is a distributed object consisting of integers merged by the
  $\max$ function; $t(x) = x + 1$ is a transaction that adds one to a state; and
  $\setst{x \in \ints}{x \geq 0}$ is the invariant that states $x$ are
  non-negative.
\end{example}

Note that we do not assume any properties of $\join$, like associativity or
commutativity. Also note that by modelling a transaction $t$ as a function $S
\to S$, we focus exclusively on the effects that a transaction has on the
object (i.e.\ ``writes'' to the object). Transactions are also free to read the
value of the object, but these reads are not captured by our model because, as
we'll see, they do not affect \invariantconfluence{}. For example, we could
model any read-only transaction as a function $t$ where $t(s) = s$ for every $s
\in S$.

In our system model, a distributed object $O$ is replicated across a set $p_1,
\ldots, p_n$ of $n$ servers. Each server $p_i$ manages a replica $s_i \in S$ of
the replicated object. Every server begins with a start state $s_0 \in S$, a
fixed set $T$ of transactions, and an invariant $I$. Servers repeatedly perform
one of two actions.

First, a client can contact a server $p_i$ and request that it
\markrevisions{executes} a transaction $t \in T$. $p_i$ speculatively executes
$t$, transitioning from state $s_i$ to state $t(s_i)$. If $t(s_i)$ satisfies
the invariant---i.e.  $I(t(s_i))$---then $p_i$ commits the transaction and
remains in state $t(s_i)$.  Otherwise, $p_i$ aborts the transaction and reverts
to state $s_i$.

Second, a server $p_i$ can send its state $s_i$ to another server $p_j$ with
state $s_j$ causing $p_j$ to transition from state $s_j$  to state $s_i \join
s_j$. Servers periodically merge states with one another in order to keep their
states loosely synchronized\footnote{%
  Notably, if $O$ is a CRDT---i.e. $O$ is a semilattice and every transaction
  $t \in T$ is inflationary---then this periodic merging ensures that $O$ is
  strongly eventually consistent~\cite{shapiro2011conflict}.
}.
Note that unlike with transactions, servers \emph{cannot} abort a merge; server
$p_j$ must transition from $s_j$ to $s_i \join s_j$ whether or not $s_i \join
s_j$ satisfies the invariant.

Informally, $O$ is \defword{\invariantconfluent{}} with respect to $s_0$, $T$,
and $I$, abbreviated \defword{\sTIconfluent{}}, if every replica $s_1, \ldots,
s_n$ is guaranteed to always satisfy the invariant $I$ in every possible
execution of the system.

\subsection{Expression-Based Formalism}
To define \invariantconfluence{} formally, we represent a state produced by a
system execution as a simple expression generated by the grammar
%
\[
  \hfill
  e ::= s \mid t(e) \mid e_1 \join e_2
  \hfill
\]
%
where $s$ represents a state in $S$ and $t$ represents a transaction in $T$. As
an example, consider the system execution in \figref{SystemExecution} in which
a distributed object is replicated across servers $p_1$, $p_2$, and $p_3$.
Server $p_3$ begins with state $s_0$, transitions to state $s_2$ by executing
transaction $u$, transitions to state $s_5$ by executing transaction $w$, and
then transitions to state $s_7$ by merging with server $p_1$. Similarly, server
$p_1$ ends up with state $s_6$ after executing transactions $t$ and $v$ and
merging with server $p_2$. In \figref{Expression}, we see the abstract syntax
tree of the corresponding expression for state $s_7$.

{\input{figures/invariant_confluence_definitions}}

We say an expression $e$ is \defword{\sTIreachable{}} if it corresponds to a
valid execution of our system model. Formally, we define
$\sTIreachablepredicate{e}$ to be the smallest predicate that satisfies the
following equations:
\begin{itemize}
  \item
    $\sTIreachablepredicate{s_0}$.
  \item
    For all expressions $e$ and for all transactions $t$ in the set $T$ of
    transactions, if $\sTIreachablepredicate{e}$ and $I(t(e))$, then
    $\sTIreachablepredicate{t(e)}$.
  \item
    For all expressions $e_1$ and $e_2$, if $\sTIreachablepredicate{e_1}$ and
    $\sTIreachablepredicate{e_2}$, then $\sTIreachablepredicate{e_1 \join
    e_2}$.
\end{itemize}
Similarly, we say a state $s \in S$ is \sTIreachable{} if there exists an
\sTIreachable{} expression $e$ that evaluates to $s$. Returning to
\exampleref{Ints} with start state $s_0 = 42$, we see that all integers greater
than or equal to 42 (i.e.\ $\setst{x \in \ints}{x \geq 42}$) are
\sTIreachable{}, and all other integers are \sTIunreachable{}.

Finally, we say $O$ is \defword{\invariantconfluent} with respect to $s_0$,
$T$, and $I$, abbreviated \defword{\sTIconfluent{}}, if all reachable states
satisfy the invariant:
\[
  \hfill
  \setst{s \in S}{\sTIreachablepredicate{s}} \subseteq I
  \hfill
\]

\subsection{Equivalence to Existing Definition}
Our definition of \invariantconfluence{} is different than the original
definition given in~\cite{bailis2014coordination}, but the difference is merely
cosmetic. We now prove that the two definitions are equivalent.

We say an expression $e$ \defword{recursively satisfies $I$}, denoted
$\Irec{e}$, if $e$ and all of $e$'s children satisfy $I$. That is,
\begin{itemize}
  \item
    $\Irec{s}$ if $I(s)$,

  \item
    $\Irec{t(e)}$ if $\Irec{e}$ and $I(t(e))$, and

  \item
    $\Irec{e_1 \join e_2}$ if $\Irec{e_1}$, $\Irec{e_2}$, and $I(e_1 \join
    e_2)$.
\end{itemize}

In~\cite{bailis2014coordination}, Bailis et al.\ define \sTIconfluence{} to
mean that (a) the start state $s_0$ satisfies the invariant and (b) all
\sTIreachable{} expressions recursively satisfying $I$ are closed under join.
That is, $O$ is \sTIconfluent{} if $I(s_0)$ and
\begin{gather*}
  \hspace{0.75in} \forall e_1, e_2 \in \setst{e}{\sTIreachablepredicate{e}}.\; \\
  \hspace{0.75in} \Irec{e_1} \land \Irec{e_2} \implies I(e_1 \join e_2)
\end{gather*}

\begin{theorem}\thmlabel{TwoIconfluenceDefs}
  Consider a state based object $O = (S, \join)$, a start state $s_0$, a set of
  transactions $T$, and an invariant $I$. The following two are equivalent:
  \begin{enumerate}
    \item
      $\setst{s \in S}{\sTIreachablepredicate{s}} \subseteq I$

    \item
      $I(s_0)$ and
      $\forall e_1, e_2 \in \setst{e}{\sTIreachablepredicate{e}}.\;
         \Irec{e_1} \land \Irec{e_2} \implies I(e_1 \join e_2)$
  \end{enumerate}
\end{theorem}
\begin{proof}
  First, we show that (1) implies (2). Trivially,
  $\sTIreachablepredicate{s_0}$, so by (1), $I(s_0)$. Let $e_1$ and $e_2$ be
  arbitrary \sTIreachable{} expressions. Then $e_1 \join e_2$ is also
  reachable, so by (1), $I(e_1 \join e_2)$.

  Next, we show that (2) implies (1). We prove by structural induction that for
  all $e$, $\sTIreachablepredicate{e} \implies \Irec{e}$. From this, (1) is
  immediate.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      $I(s_0)$ by (2), so $\Irec{s_0}$

    \item \textbf{Case $t(e)$.}
      Let $t(e)$ be \sTIreachable{}. Then, $\sTIreachablepredicate{e}$ and
      $I(t(e))$. By the inductive hypothesis, $\Irec{e}$, so by the definition
      of $\Irec{\cdot}$, $\Irec{t(e)}$.

    \item \textbf{Case $e_1 \join e_2$.}
      Let $e_1 \join e_2$ be \sTIreachable{}. Then,
      $\sTIreachablepredicate{e_1}$ and $\sTIreachablepredicate{e_2}$. By the
      inductive hypothesis, $\Irec{e_1}$ and $\Irec{e_2}$. By $(2)$, $I(e_1
      \join e_2)$. Thus, by the definition of $\Irec{\cdot}$, $\Irec{e_1 \join
      e_2}$.
  \end{itemize}
\end{proof}
