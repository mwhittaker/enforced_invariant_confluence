\section{Operation Based Invariant Confluence}
In the system model we described, a server $p_i$ periodically sends its state
$s_i$ to some other server $p_j$ for merging. In this ``state-based'' model,
states are sent between replicas but transactions are not. Borrowing a trick
from CRDTs~\cite{shapiro2011conflict, shapiro2011comprehensive}, we can define
an alternate, but equivalent, ``operation-based'' system model in which
transactions are sent between replicas but states are not. Though the two
models are equivalent, the operation-based approach is sometimes more natural.
For example, with the operation-based approach, we can replace the PN-counter
from \exampleref{CounreachableExample} with a simple integer.

\subsection{System Model}
A \defword{distributed operation-based object} is a set $O = S$ of states. Note
that we do not have a merge function like we did with state-based objects.
%
An \defword{operation-based transaction} $t: S \to (S \to S)$ is a function
that maps a state $s$ to a \defword{shadow transaction} $t(s): S \to
S$~\cite{li2014automating}.
%
The definition of an invariant is the same in the state-based and
operation-based models.

\begin{example}
  $\nats$ is a distributed operation-based object. $t: \nats \to (\nats \to
  \nats)$ is an operation-based transaction where $t(x)(y) = x + y$. That is,
  given a state $x$, $t(x)$ is the function $f_x$ where $f_x(y) = x + y$.
\end{example}

In our operation-based system model, a distributed object $O$ is replicated
across a set $p_1, \ldots, p_n$ of $n$ servers. Each server $p_i$ manages a
replica $s_i \in O$ of the replicated object. Every server begins with a start
state $s_0 \in S$, a fixed set $T$ of transactions, and an invariant $I$.
Servers repeatedly perform one of two actions.

First, a client can contact a server $p_i$ and request that it execute a
transaction $t \in T$. $p_i$ speculatively executes $t(s_i)$, transitioning
from state $s_i$ to state $t(s_i)(s_i)$. If $t(s_i)(s_i)$ does not satisfy the
invariant, then $p_i$ aborts the transaction and reverts to state $s_i$.
Otherwise, $p_i$ commits the transaction and remains in state $t(s_i)(s_i)$. It
also broadcasts the shadow transaction $t(s_i)$ in an exactly-once manner to
the rest of the servers.

Second, $p_j$ can receive a shadow transaction $t(s_i)$ from some other server
$p_i$. When $p_j$ receives $t(s_i)$, it transitions from its state $s_j$ to
state $t(s_i)(s_j)$. When $p_j$ receives a shadow transaction, it must execute
it, even if $\lnot I(t(s_i)(s_j))$.

Informally, $O$ is \invariantconfluent{} with respect to $s_0$, $T$, and $I$ if
every replica $s_1, \ldots, s_n$ is guaranteed to always satisfy the invariant
$I$ in every possible execution of the system.

% As with state-based objects, there are three ways to think about
% operation-based invariant-confluence: a process-based approach, a graph-based
% approach, and an expression-based approach. All three approaches are
% illustrated in \figref{OpBasedModels} and are described in more detail below.
%
% \input{figs/opbased_iconfluence.fig}
%
% \subsubsection{Process-Based}
% As with the state-based approach, the process-based model is most similar to
% the process model described by Shapiro et al.\ in~\cite{shapiro2011conflict}.
% We are given an operation-based object $O$, a start state $s_0$, a set of
% transactions $T$, an invariant $I$, and a set $\seq{p}{1}{n}$ of $n$
% processors. Each processors begins with state $s_0$. A processor $p_i$ can do
% one of two things.
%
% \begin{itemize}
%   \item
%     $p_i$ can execute a transaction $t$ on its current state $s$ and then
%     transitions from state $s$ to state $t(s)(s)$, given that $I(t(s)(s))$. If
%     $\lnot I(t(s)(s))$, then $p_i$ will not perform $t$. If $p_i$ does execute
%     $t$, then it broadcasts $t(s)$ to all other processors exactly once.
%
%   \item
%     $p_i$ can receive a broadcast shadow transaction $t(s_j)$ from some other
%     processor $p_j$. When $p_i$ receives $t(s_j)$, it transitions from its
%     state $s_i$ to state $t(s_j)(s_i)$. When $p_i$ receives a shadow
%     transaction, it must execute it, even if $\lnot I(t(s_j)(s_i))$.
% \end{itemize}
%
% $O$ is \sTIconfluent{} if every reachable state (including $s_0$) satisfies the
% invariant.
%

\subsection{Expression-Based Formalism}
To define operation-based \invariantconfluence{} formally, we represent a state
produced by an operation-based system execution as a simple expression
generated by the grammar
%
\[
  \hfill
  e ::= s \mid t(e_1)(e_2)
  \hfill
\]
%
where $s$ represents a state in $S$ and $t$ represents a transaction in $T$. As
an example, consider the system execution in \figref{OpSystemExecution} in
which a distributed object is replicated across servers $p_1$, $p_2$, and
$p_3$. Server $p_3$ begins with state $s_0$, receives transaction $t$,
transitions to state $s_1$ by executing shadow transaction $t(s_0)$,
transitions to state $s_3$ by executing shadow transaction $u(s_0)$, and then
transitions to state $s_7$ by executing shadow transaction $v(s_2)$.  In
\figref{OpExpression}, we see the abstract syntax tree of the corresponding
expression for state $s_7$.

{\input{figures/operation_based_invariant_confluent_definitions.tex}}

We say an expression $e$ is \defword{\sTIreachable{}} if it corresponds to a
valid execution of our system model. Formally, we define
$\sTIreachablepredicate{e}$ to be the smallest predicate that satisfies the
following equations:
\begin{itemize}
  \item
    $\sTIreachablepredicate{s_0}$.
  \item
    For all expressions $e_1, e_2$ and for all transactions $t$ in $T$, if
    $\sTIreachablepredicate{e_1}$, $\sTIreachablepredicate{e_2}$, and
    $I(t(e_1)(e_1))$, then $\sTIreachablepredicate{t(e_1)(e_2)}$.
\end{itemize}

Finally, we say $O$ is \invariantconfluent{} with respect to $s_0$, $T$, and
$I$, abbreviated \sTIconfluent{}, if all reachable states satisfy the
invariant:
\[
  \hfill
  \setst{s \in S}{\sTIreachablepredicate{s}} \subseteq I
  \hfill
\]
