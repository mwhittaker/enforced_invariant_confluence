\section{Sufficient Conditions}
In this section, we present sufficient (but not always necessary) conditions
for state-based and operation-based invariant-confluence. We also explain
circumstances under which the sufficient conditions are also necessary.

\begin{definition}
  We say a state-based object $O = (S, \join)$ is \defword{\Iclosed{}} if for
  all states $s_1$ and $s_2$, if $I(s_1)$ and $I(s_2)$, then $I(s_1 \join
  s_2)$.
  \[
    I(s_1) \land I(s_2) \implies I(s_1 \join s_2)
  \]
  Similarly, we say on operation-based object $O = S$ is \defword{\Iclosed{}}
  if for all states $s_1$ and $s_2$ and all transactions $t$, if $I(s_1)$,
  $I(s_2)$, and $I(t(s_1)(s_1))$, then $I(t(s_1)(s_2))$.
  \[
    I(s_1) \land I(s_2) \land I(t(s_1)(s_1)) \implies I(t(s_1)(s_2))
  \]
\end{definition}

\begin{claim}\clmlabel{StateBasedSufficient}
  Given a state-based object $O = (S, \join)$, a start state $s_0$, a set of
  transactions $T$, and an invariant $I$, if $O$ is \Iclosed{} and $I(s_0)$,
  then $O$ is \sTIconfluent.
\end{claim}
\begin{elidableproof}
  Let $e_1, e_2$ be $\sTIreachable{}$ expressions such that $\Irec{e_1}$ and
  $\Irec{e_2}$. Let $s_1 = eval(e_1)$ and $s_2 = eval(e_2)$. Then, $I(s_1)$ and
  $I(s_2)$. Because $O$ is \Iclosed{}, $I(s_1 \join s_2)$, so $I(e_1 \join
  e_2)$. Thus, by \clmref{StateBasedTwoIconfluenceDefs}, $O$ is
  \sTIconfluent{}.
\end{elidableproof}

\begin{claim}\clmlabel{OpBasedSufficient}
  Given a operation-based object $O = S$, a start state $s_0$, a set of
  transactions $T$, and an invariant $I$, if $O$ is \Iclosed{} and $I(s_0)$,
  then $O$ is \sTIconfluent.
\end{claim}
\begin{elidableproof}
  Let $t \in T$ and $e_1, e_2$ be $\sTIreachable{}$ expressions such that
  $\Irec{e_1}$, $\Irec{e_2}$, and $I(t(e_1)(e_1))$. Let $s_1 = eval(e_1)$ and
  $s_2 = eval(s_2)$. Then, $I(s_1)$, $I(s_2)$, $I(t(s_1)(s_1))$, so
  $I(t(s_1)(s_2))$ because $O$ is \Iclosed. Thus, $I(t(e_1)(e_2))$, so by
  \clmref{OpBasedTwoIconfluenceDefs}, $O$ is \sTIconfluent.
\end{elidableproof}

As a special case, \clmref{StateBasedSufficient} tells us that a state-based
object $O$ is \sTIconfluent{} if $I$ is monotonic and $O$ is a semilattice.

\begin{claim}\clmlabel{Monotonicity}
  Let $O = (S, \join)$ be a semilattice. Let $s \leq s' \defeq s \join s' =
  s'$. Let $s_0$ be an arbitrary start state. Let $T$ be an arbitrary set of
  transactions. Let invariant $I$ be \defword{monotonic}: for all $s, s'\in S$,
  if $s \leq s'$, then $I(s) \implies I(s')$. Also assume $I(s_0)$. Then, $T$
  is \sTIconfluent{}.
\end{claim}
\begin{elidableproof}
  Let $s_1$ and $s_2$ be arbitrary states such that $I(s_1)$ and $I(s_2)$. $s_1
  \leq s_1 \join s_2$, so by monotonicity, $I(s_1 \join s_2)$. Thus, by
  \clmref{StateBasedSufficient}, $O$ is \sTIconfluent{}.
\end{elidableproof}

Unfortunately, the converses of \clmref{StateBasedSufficient} and
\clmref{OpBasedSufficient} are not true. Being \sTIconfluent{} does not
necessarily imply being \Iclosed{}, as the next two examples show.

\begin{example}\examplelabel{StateBasedNotNecessary}
  Consider the state-based object $O = (S, \join) = (\ints, \max) \times
  (\ints, \max)$ and start state $s_0 = (0, 0)$. Let $T$ consist of two
  transactions $t_{x+1} \defeq \lambda (x, y).\ (x + 1, y)$ and $t_{y-1} =
  \lambda (x, y).\ (x, y - 1)$. Let $I = \setst{(x, y)}{xy \leq 0}$.

  $\setst{(x, y)}{\sTIreachable{(x, y)}} = \nats \times -\nats \subseteq I$, so
  $O$ is \sTIconfluent. However, let $s_1 = (-1, 1)$ and $s_2 = (1, -1)$.
  $I(s_1)$ and $I(s_2)$. However, $s_1 \join s_2 = (1, 1)$, and $\lnot I((1,
  1))$. Thus, $O$ is not \Iclosed{}.
\end{example}

\begin{example}
  Consider the operation-based object $O = S = \ints \times \ints$ and start
  state $s_0 = (0, 0)$. Let $T$ consist of two transactions $t_{x+1} \defeq
  \lambda s.\ \lambda (x, y).\ (x + 1, y)$ and $t_{y-1} = \lambda s.\ \lambda
  (x, y).\ (x, y - 1)$. Let $I = \setst{(x, y)}{xy \leq 0}$.
  %
  $\setst{(x, y)}{\sTIreachable{(x, y)}} = \nats \times -\nats \subseteq I$, so
  $O$ is \sTIconfluent. However, let $s_1 = (1, -1)$ and $s_2 = (0, 1)$.
  $I(s_1)$, $I(s_2)$, and $I(t_{x+1}(s_1)(s_1))$. However, $t_{x+1}(s_1)(s_2) =
  (1, 1)$, and $\lnot I((1, 1))$. Thus, $O$ is not \Iclosed{}.
\end{example}

\input{figs/not_necessary.fig}

Let's take a closer look at \exampleref{StateBasedNotNecessary} (illustrated in
\figref{StateBasedNotNecessary}) to understand why being \sTIconfluent{}
doesn't imply being \Iclosed{}. Our counterexample considers points $s_1 = (-1,
1)$ and $s_2 = (1, -1)$. $s_2$ is reachable, but $s_1$ is not. This is not a
coincidence! If we consider an \sTIconfluent{} object and set of transactions,
then any two reachable points satisfy the invariant, and the join of the two
points is again reachable, so it must satisfy the invariant as well. The only
way to join two invariant satisfying points and end up \emph{not} satisfying
the invariant is if one or both points are not reachable. Thus, if we know that
$I$ is a subset of reachable points, then being \sTIconfluent{} and being
\Iclosed{} are equivalent.

\begin{claim}\clmlabel{SufficientAndNecessary}
  If every invariant satisfying state is reachable, then being \sTIconfluent{}
  and being \Iclosed{} are equivalent.
  \[
    I \subseteq \setst{s}{\sTIreachable{s}} \implies
    (I(s_0) \land \text{$O$ \Iclosed{}} \iff \text{$O$ \sTIconfluent})
  \]
\end{claim}
\begin{elidableproof}
  Consider a state-based object $O = (S, \join)$, a start state $s_0$, a set of
  transactions $T$, and an invariant $I$ where $I \subseteq
  \setst{s}{\sTIreachable{s}}$.
  %
  If $I(s_0)$ and $O$ is \Iclosed{}, then $O$ is \sTIconfluent{} whether or not
  $I \subseteq \setst{s}{\sTIreachable{s}}$. Thus, we only have to prove that
  if $O$ is \sTIconfluent{}, then $I(s_0)$ and $O$ is \Iclosed.
  %
  If $O$ is \sTIconfluent{}, then $I(s_0)$. Next, let $s_1$ and $s_2$ be
  arbitrary states such that $I(s_1)$ and $I(s_2)$. Both states satisfy the
  invariant, so both are reachable. That is, there exist expressions $e_1$ and
  $e_2$ where $eval(e_1) = s_1$  and $eval(e_2) = s_2$. $e_1 \join e_2$ is
  again reachable, so since $T$ is \sTIconfluent{}, $I(s_1 \join s_2)$.  Thus,
  $O$ is \Iclosed.
\end{elidableproof}

Here are some more examples of transactions $T$ and invariants $I$ that are
\sTIconfluent{} but not \Iclosed{}.

\todo{Think of more compelling examples.}

\begin{example}
  \todo{Write this up in full.}
  Imagine we are building a system to group students together. We have a relation
  of (student id, grade) and a map (group id -> set of student ids). We want to
  enforce the invariant that every student in every group is in the same grade
  and that all groups are non-empty. If we start off with an initially empty
  mapping, then there are conflicts. If we start off with at least one student
  mapped into each group, then there are not any conflicts.
\end{example}

\begin{example}
  Consider the state-based object $O = (\powerset{\nats}, \cup)$ and start
  state $s_0 = \set{0}$. Let $T = \setst{\lambda X.\ X \cup Y}{Y \subseteq
  \nats}$ let $I = \setst{X}{\text{$X$ contains only odd or only even
  elements}}$. The $\sTIreachable{}$ states are $\powerset{2\nats}$, all of
  which satisfy $I$, so $O$ is \sTIconfluent{}.  However, let $A = \set{0}$ and
  $Y = \set{1}$. $I(A)$ and $I(B)$, but $A \join B = \set{0, 1}$ does not
  satisfy $I$.
\end{example}

\begin{example}
  Consider a state-based object consisting of two integer 2P-sets $(A_1, R_1)$
  and $(A_2, R_2)$ with initial state $(\set{1, 3}, \emptyset{})$ and $(\set{1,
  2, 3, 4}, \emptyset{})$. Let $T$ consist of all transactions that either
  remove an element from the first 2P-set (i.e.\ add something to $R_1$) or add
  something to the second 2P-set (i.e.\ add something to $A_2$). Let $I$ be
  that the first 2P-set is a subset of the second (i.e. $(A_1 - R_1) \subseteq
  (A_2 - R_2)$).
  %
  $O$ is \sTIconfluent{}. However, let $s_1 = (\set{1}, \set{2}, \set{1},
  \set{2})$ and $s_2 = (\set{2}, \set{1}, \set{2}, \set{1})$. $I(s_1)$ and
  $I(s_2)$, but $s_1 \cup s_2 = (\set{1, 2}, \set{1, 2}, \set{1, 2}, \set{1,
  2})$ which does not satisfy $I$.
\end{example}
