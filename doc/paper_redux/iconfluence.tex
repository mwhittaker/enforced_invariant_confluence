\section{\Iconfluence{}}
In this section, we present six different ways to think about \Iconfluence{}:
three state-based approaches and three operation-based approaches.

\subsection{State-Based}
\begin{definition}
  A \defword{distributed state-based object} $O$ is a triple $(S, s_0, \join)$
  where $S$ is a set of states, $s_0 \in S$ is a designated start state, and
  $\join: S \times S \to S$ is a binary merge operator that we call join.
\end{definition}

The notion of state-based objects is taken from~\cite{shapiro2011conflict}.
Note that $\join$ is an \emph{arbitrary} function. It does not necessarily have
to satisfy any special properties like associativity or commutativity.

\begin{definition}
  A \defword{state-based transaction} $t: S \to S$ is a function that maps one
  state to another.
\end{definition}

\begin{definition}
  An \defword{invariant} $I \subseteq S$ is a subset of states. Notationally,
  we say $I(s)$ to mean $s \in I$ and $\lnot I(s)$ to mean $s \notin I$.
\end{definition}

We formalize an invariant as a set of states, but we can also think of a
predicate as a formula over states. For example, we can think of the invariant
$\setst{(x, y) \in \ints \times \ints}{x \geq y}$ as the formula $x \geq y$ and
vice-versa.

\begin{example}
  $(\nats, 0, +)$ is a distributed object, $t(x) = 2x$ is a transaction, and
  $\setst{x \in \nats}{\text{$x$ is even}}$ is an invariant. Here, $I(0)$ and
  $I(2)$ but $\lnot I(1)$ and $\lnot I(3)$.
\end{example}

There are three ways to think about state-based \Iconfluence{}: a process-based
approach, a graph-based approach, and an expression-based approach. Below, we
describe the process-based approach and the graph-based approach informally and
describe the expression-based approach formally. All three approaches are
illustrated in \figref{StateBasedModels}.

\input{figs/statebased_iconfluence.fig}

\subsubsection{Process-Based}
The process-based model is most similar to the process model described by
Shapiro et al.\ in~\cite{shapiro2011conflict}. We are given a state-based
object $O = (S, s_0, \join)$, a set of transactions $T$, an invariant $I$, and
a set $\seq{p}{1}{n}$ of $n$ processors. Each processor begins with state
$s_0$. A processor $p_i$ can perform one of two actions.

\begin{itemize}
  \item
    $p_i$ can execute a transaction $t \in T$ to transition from state $s$ to
    state $t(s)$, given that $I(t(s))$. If $\lnot I(t(s))$, then $p_i$ will not
    execute $t$ (or it will execute $t$ but then abort it; think of it however
    you like).

  \item
    $p_i$ can send its state $s_i$ to another processor $p_j$ with state $s_j$
    causing $p_j$ to transition from state $s_j$ to state $s_i \join s_j$ (or
    $s_j \join s_i$; it doesn't really matter). Note that unlike executing a
    transaction, $p_j$ must transition from $s_j$ to $s_i \join s_j$ even if
    $\lnot I(s_i \join s_j)$.
\end{itemize}

$(O, T)$ is invariant-confluent with respect to $I$ (abbreviated \Iconfluent{})
if every reachable state (including $s_0$) satisfies the invariant. Note that
this definition of \Iconfluence{} is different from the original definition
in~\cite{bailis2014coordination}. Later, we will see that they are equivalent.

\subsubsection{Graph-Based}
The graph-based approach is most similar to the model used by Bailis et al.\
in~\cite{bailis2014coordination}. We are given a directed acyclic graph where
vertices are states, and edges are either labelled with transactions or are
unlabelled if they correspond to a join. The graph is really just an alternate
way of representing an execution in the process-based model, but with duplicate
states collapsed into a single vertex. As with the process-based model, we say
that $(O, T)$ is \Iconfluent{} if every vertex in every graph satisfies the
invariant.

\subsubsection{Expression-Based}
The expression-based approach formalizes the process-based and graph-based
approach using expressions. Given a state based object $O = (S, s_0, \join)$
and a set of transactions $T$, we consider expressions generated by the
following grammar:
\[
  e ::= s_0 \mid t(e) \mid e_1 \join e_2
\]
where $t$ corresponds to a transaction in $T$. We can evaluate an expression
$e$, written $eval(e)$, in the obvious way:
\begin{mathpar}
  eval(s_0) \defeq s_0

  eval(t(e)) \defeq t(eval(e))

  eval(e_1 \join e_2) \defeq eval(e_1) \join eval(e_2)
\end{mathpar}

\begin{definition}
  An expression $e$ \defword{satisfies $I$}, denoted $I(e)$, if $I(eval(e))$.
\end{definition}

\begin{definition}
  Intuitively, we say an expression is \defword{reachable} if it can be reached
  in an execution of the process-based model. Formally, we defined a predicate
  $\reachable{\cdot}$ as follows:

  \begin{mathpar}
    \inferrule{ }{\reachable{s_0}}

    \inferrule{\reachable{e} \\ I(t(e))}{\reachable{t(e})}

    \inferrule{\reachable{e_1} \\ \reachable{e_2}}{\reachable{e_1 \join e_2}}
  \end{mathpar}
\end{definition}

\begin{definition}
  $(O, T)$ is \defword{\Iconfluent{}} if $\setst{e}{\reachable{e}} \subseteq
  I$. In other words, $T$ is \Iconfluent{} if all reachable states satisfy the
  invariant.
\end{definition}

As we mentioned earlier, this definition of \Iconfluence{} is different than
the original definition presented in~\cite{bailis2014coordination} (though it
is the same as the definition in~\cite{gotsman2016cause}), but they are
(almost) equivalent. We introduce some definitions and then prove this.

\begin{definition}
  An expression \defword{recursively satisfies $I$}, denoted $\Irec{e}$, if $e$
  and all of $e$'s children satisfy $I$. That is,
  \begin{mathpar}
    \inferrule{I(s_0)}{\Irec{s_0}}

    \inferrule{I(t(e)) \\ \Irec{e}}{\Irec{t(e)}}

    \inferrule{I(e_1 \join e_2) \\ \Irec{e_1} \\ \Irec{e_2}}
              {\Irec{e_1 \join e_2}}
  \end{mathpar}
\end{definition}

Bailis et al.\ defined \Iconfluence{} to mean that expressions recursively
satisfying $I$ are closed under join. That is, $(O, T)$ is \Iconfluent{} if
\[
  \forall e_1, e_2.\; \Irec{e_1} \land \Irec{e_2} \implies I(e_1 \join e_2)
\]
If $\lnot I(s_0)$, then \Iconfluence{} holds vacuously which is a bit silly, so
Bailis et al.\ probably ought to have also added the condition $I(s_0)$ to
their definition of \Iconfluence{}. Doing so, the two definitions become
equivalent.

\begin{lemma}\lemlabel{StateBasedIrecImpliesReachable}
  $\Irec{e} \implies \reachable{e}$
\end{lemma}
\begin{elidableproof}
  We perform structural induction on $e$.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      Axiomatically, $\reachable{s_0}$.

    \item \textbf{Case $t(e)$.}
      $\Irec{t(e)}$, so $I(t(e))$ and $\Irec{e}$. By the inductive hypothesis,
      $\reachable{e}$, so by the definition of $\reachable{\cdot}$,
      $\reachable{t(e)}$.

    \item \textbf{Case $e_1 \join e_2$.}
      $\Irec{t(e)}$, so $\Irec{e_1}$ and $\Irec{e_2}$. By the inductive
      hypothesis, $\reachable{e_1}$ and $\reachable{e_2}$, so by the definition
      of $\reachable{\cdot}$, $\reachable{e_1 \join e_2}$.
  \end{itemize}
\end{elidableproof}

\begin{claim}\clmlabel{StateBasedTwoIconfluenceDefs}
  Consider a state based object $O = (S, s_0, \join)$, a set of transactions
  $T$, and an invariant $I$. The following two are equivalent:
  \begin{enumerate}[\quad(1)]
    \item
      $\setst{e}{\reachable{e}} \subseteq I$

    \item
      $I(s_0)$ and $\Irec{e_1} \land \Irec{e_2} \implies I(e_1 \join e_2)$
  \end{enumerate}
\end{claim}
\begin{elidableproof}
  First, we show that (1) implies (2). Axiomatically, $\reachable{s_0}$, so by
  (1), $I(s_0)$. Let $e_1$ and $e_2$ be arbitrary expressions such that
  $\Irec{e_1}$ and $\Irec{e_2}$. By \lemref{StateBasedIrecImpliesReachable},
  $\reachable{e_1}$ and $\reachable{e_2}$. Thus, $\reachable{e_1 \join e_2}$,
  so by (1), $I(e_1 \join e_2)$.

  Next, we show that (2) implies (1). We prove by structural induction that for
  all $e$, $\reachable{e} \implies \Irec{e}$. From this, (1) is immediate.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      $I(s_0)$ by (2), so $\Irec{s_0}$

    \item \textbf{Case $t(e)$.}
      $\reachable{t(e)}$, so $\reachable{e}$ and $I(t(e))$. By the inductive
      hypothesis, $\Irec{e}$, so by the definition of $\Irec{\cdot}$,
      $\Irec{t(e)}$.

    \item \textbf{Case $e_1 \join e_2$.}
      $\reachable{e_1 \join e_2}$, so $\reachable{e_1}$ and $\reachable{e_2}$.
      By the inductive hypothesis, $\Irec{e_1}$ and $\Irec{e_2}$. By $(2)$,
      $I(e_1 \join e_2)$. Thus, $\Irec{e_1 \join e_2}$.
  \end{itemize}
\end{elidableproof}

\subsection{Operation-Based}
\begin{definition}
  A \defword{distributed operation-based object} is a pair $O = (S, s_0)$ where
  $S$ is a set of states and $s_0 \in S$ is a designated start state.
\end{definition}

Like state-based objects, the notion of operation-based objects is taken
from~\cite{shapiro2011conflict}. Note that we do not have a join function like
we did with state-based objects.

\begin{definition}
  An \defword{operation-based transaction} $t: S \to (S \to S)$ is a function
  that maps a state to a \defword{shadow transaction} $t(s): S \to S$. The term
  shadow transaction is taken from~\cite{li2014automating}.
\end{definition}

The definition of an invariant is the same in the state-based and
operation-based model.

\begin{example}
  $(\nats, 0)$ is a distributed object. $t(x) = \lambda y.\ x + y$ is a
  transaction that given a state $x$ returns a function $\lambda y.\ x + y$
  that adds $x$ to its argument. $\setst{x \in \nats}{x \geq 0}$ is an
  invariant.
\end{example}

As with state-based objects, there are three ways to think about
operation-based \Iconfluence{}: a process-based approach, a graph-based
approach, and an expression-based approach. All three approaches are
illustrated in \figref{OpBasedModels} and are described in more detail below.

\input{figs/opbased_iconfluence.fig}

\subsubsection{Process-Based}
As with the state-based approach, the process-based model is most similar to
the process model described by Shapiro et al.\ in~\cite{shapiro2011conflict}.
We are given an operation-based object $O$, a set of transactions $T$, an
invariant $I$, and a set $\seq{p}{1}{n}$ of $n$ processors. Each processors
begins with state $s_0$. A processor $p_i$ can do one of two things.

\begin{itemize}
  \item
    $p_i$ can execute a transaction $t$ on its current state $s$ and then
    transitions from state $s$ to state $t(s)(s)$, given that $I(t(s)(s))$. If
    $\lnot I(t(s)(s))$, then $p_i$ will not perform $t$. If $p_i$ does execute
    $t$, then it broadcasts $t(s)$ to all other processors exactly once.

  \item
    $p_i$ can receive a broadcasted shadow transaction $t(s_j)$ from some other
    processor $p_j$. When $p_i$ receives $t(s_j)$, it transitions from its
    state $s_i$ to state $t(s_j)(s_i)$. When $p_i$ receives a shadow
    transaction, it must execute it, even if $\lnot I(t(s_j)(s_i))$.
\end{itemize}

$(O, T)$ is \Iconfluent{} if every reachable state (including $s_0$) satisfies
the invariant.

\subsubsection{Graph-Based}
In the graph-based model, we are given a directed acyclic graph in which each
vertex is a state $s$ and each edge is labelled with a shadow operation $t(s)$
where $s$ is some other vertex in the graph. $(O, T)$ is \Iconfluent{} if every
vertex in every graph satisfies $I$.

\subsubsection{Expression-Based}
Given an operation-based object $O = (S, s_0)$ and a set of transactions $T$,
we consider expressions built from the following grammar:
\[
  e ::= s_0 \mid t(e_1)(e_2)
\]
where $t$ corresponds to a transaction in $T$. We can evaluate an expression,
denoted $eval(e)$, in the obvious way:
\begin{mathpar}
  eval(s_0) \defeq s_0

  eval(t(e_1)(e_2)) \defeq t(eval(e_1))(eval(e_2))
\end{mathpar}

\begin{definition}
  An expression $e$ \defword{satisfies $I$}, denoted $I(e)$, if $I(eval(e))$.
\end{definition}

\begin{definition}
  As with state-based expressions, we formalize which operation-based
  expressions are reachable.

  \begin{mathpar}
    \inferrule{ }{\reachable{s_0}}

    \inferrule{
      \reachable{e_1} \\
      \reachable{e_2} \\
      I(t(e_1)(e_1))
    }{\reachable{t(e_1)(e_2)}}
  \end{mathpar}
\end{definition}

\begin{definition}
  $(O, T)$ is \defword{\Iconfluent{}} if $\setst{e}{\reachable{e}} \subseteq
  I$.
\end{definition}

As with state-based objects, we have an equivalent definition of \Iconfluence{}
that deals with the closure of recursively invariant satisfying states.

\begin{definition}
  An expression \defword{recursively satisfies $I$}, denoted $\Irec{e}$, if $e$
  and all of $e$'s children satisfy $I$. That is,
  \begin{mathpar}
    \inferrule{I(s_0)}{\Irec{s_0}}

    \inferrule{I(t(e_1)(e_2)) \\ \Irec{e_1} \\ \Irec{e_2}}{\Irec{t(e_1)(e_2)}}
  \end{mathpar}
\end{definition}

\begin{lemma}\lemlabel{OpBasedIrecImpliesReachable}
  $\Irec{e} \implies \reachable{e}$
\end{lemma}
\begin{elidableproof}
  We perform a structural induction on $e$.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      Axiomatically, $\reachable{s_0}$.

    \item \textbf{Case $t(e_1)(e_2)$.}
      $\Irec{t(e_1)(e_2)}$, so $\Irec{e_1}$, $\Irec{e_2}$, and
      $I(t(e_1)(e_1))$. By the inductive hypothesis, $\reachable{e_1}$ and
      $\reachable{e_2}$. Thus, $\reachable{t(e_1)(e_2)}$.
  \end{itemize}
\end{elidableproof}

\begin{claim}\clmlabel{OpBasedTwoIconfluenceDefs}
  Given an operation-based object $(S, s_0)$, a set of transactions $T$, and an
  invariant $I$, the following two are equivalent:
  \begin{enumerate}[\quad(1)]
    \item
      $\setst{e}{\reachable{e}} \subseteq I$

    \item
      $I(s_0)$ and $\Irec{e_1} \land \Irec{e_2} \land I(t(e_1)(e_1)) \implies
      I(t(e_1)(e_2))$.
  \end{enumerate}
\end{claim}
\begin{elidableproof}
  First, we show that (1) implies (2). $\reachable{s_0}$, so by (1), $I(s_0)$.
  Let $e_1$ and $e_2$ be arbitrary expressions such that $\Irec{e_1}$,
  $\Irec{e_2}$, and $I(t(e_1)(e_1))$. By \lemref{OpBasedIrecImpliesReachable},
  $\reachable{e_1}$ and $\reachable{e_2}$, so $\reachable{t(e_1)(e_2)}$. By
  (1), $I(t(e_1)(e_2))$.

  Next, we show that (2) implies (1). We show by structural induction on $e$
  that $\reachable{e} \implies \Irec{e}$. From this, (1) is immediate.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      By (2), $I(s_0)$, so $\Irec{s_0}$.

    \item \textbf{Case $t(e_1)(e_2)$.}
      $\reachable{t(e_1)(e_2)}$, so $\reachable{e_1}$, $\reachable{e_2}$, and
      $I(t(e_1)(e_1))$. By the inductive hypothesis, $\Irec{e_1}$ and
      $\Irec{e_2}$. By (2), $I(t(e_1)(e_2))$, so $\Irec{t(e_1)(e_2)}$.
  \end{itemize}
\end{elidableproof}
