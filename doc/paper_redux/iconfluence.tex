\section{\Iconfluence{}}
In this section, we present six different ways to think about \Iconfluence{}:
three state-based approaches and three operation-based approaches.

\subsection{State-Based}
\begin{definition}
  A \defword{distributed state-based object} is a triple $(S, s_0, \join)$
  where $S$ is a set of states, $s_0 \in S$ is a designated start state, and
  $\join: S \times S \to S$ is a binary merge operator that we call join.
\end{definition}

The notion of state-based objects is taken from~\cite{shapiro2011conflict}.
Note that $\join$ is an \emph{arbitrary} function. It does not necessarily have
to satisfy any special properties like associativity or commutativity, though
later we will see that often it does.

\begin{definition}
  A \defword{state-based transaction} $t: S \to S$ is a function that maps one
  state to another.
\end{definition}

\begin{definition}
  An \defword{invariant} $I \subseteq S$ is a subset of states. Notationally,
  we say $I(s)$ to mean $s \in I$ and $\lnot I(s)$ to mean $s \notin I$.
\end{definition}

\begin{example}
  $(\nats, 0, +)$ is a distributed object, $t(x) = 2x$ is a transaction, and
  $\setst{x \in \nats}{x \equiv 0 \mod 2}$ is an invariant. Here, $I(0)$ and
  $I(2)$ but $\lnot I(1)$ and $\lnot I(3)$.
\end{example}

There are three ways to think about state-based \Iconfluence{}: a process-based
approach, a graph-based approach, and an expression-based approach. All three
approaches are illustrated in \figref{statebasedmodels} and are described in
more detail below.

\input{figs/statebased_iconfluence.fig}

\subsubsection{Process-Based}
The process-based model is most similar to the process model described by
Shapiro et al.\ in~\cite{shapiro2011conflict}. We are given a set
$\seq{p}{1}{n}$ of $n$ processors each of which begins with state $s_0$.  A
processor $p_i$ can perform one of two actions.

First, $p_i$ can execute a transaction $t \in T$ to transition from state $s$
to state $t(s)$, given that $I(t(s))$. If $\lnot I(t(s))$, then $p_i$ will not
execute $t$ (or it will execute $t$ but then abort it; think of it however you
like).

Second, $p_i$ can send its state $s_i$ to another processor $p_j$ with state
$s_j$ causing $p_j$ to transition from state $s_j$ to state $s_i \join s_j$ (or
$s_j \join s_i$; it doesn't really matter). Note that unlike executing a
transaction, $p_j$ must transition from $s_j$ to $s_i \join s_j$ even if $\lnot
I(s_i \join s_j)$.

$T$ is invariant-confluent with respect to $I$, abbreviated \Iconfluent{}, if
every reachable state (including $s_0$) satisfies the invariant. Note that this
definition of \Iconfluence{} is different from the original definition
in~\cite{bailis2014coordination}. Later, we will see that they are equivalent.

\subsubsection{Graph-Based}
The graph-based approach is most similar to the model used by Bailis et al.\
in~\cite{bailis2014coordination}. We are given a directed acyclic graph where
vertices are states, and edges are either labelled with transactions or are
unlabelled if they correspond to a join. The graph is really just an alternate
way of representing an execution in the process-based model, but with duplicate
states collapsed into a single vertex. As with the process-based model, we say
that $T$ is \Iconfluent{} if every vertex in every graph satisfies the
invariant.

\subsubsection{Expression-Based}
The expression-based approach formalizes the process-based and graph-based
approach using expressions. Given a state based object $(S, s_0, \join)$ and a
set of transactions $T$, we consider expressions generated by the following
grammar:
\[
  e ::= s_0 \mid t(e) \mid e_1 \join e_2
\]
where $t$ corresponds to a transaction in $T$. We can evaluate an expression
$e$, written $eval(e)$, in the obvious way:
\begin{mathpar}
  eval(s_0) \defeq s_0

  eval(t(e)) \defeq t(eval(e))

  eval(e_1 \join e_2) \defeq eval(e_1) \join eval(e_2)
\end{mathpar}

\begin{definition}
  An expression $e$ \defword{satisfies $I$}, denoted $I(e)$, if $I(eval(e))$.
\end{definition}

\begin{definition}
  Intuitively, we say an expression is \defword{reachable} if it can be reached
  in an execution of the process-based model. Formally, we defined a predicate
  $\reachable{\cdot}$ as follows:

  \begin{mathpar}
    \inferrule{ }{\reachable{s_0}}

    \inferrule{\reachable{e} \\ I(t(e))}{\reachable{t(e})}

    \inferrule{\reachable{e_1} \\ \reachable{e_2}}{\reachable{e_1 \join e_2}}
  \end{mathpar}
\end{definition}

\begin{definition}
  $T$ is \defword{\Iconfluent{}} if $\setst{e}{\reachable{e}} \subseteq I$. In
  other words, $T$ is \Iconfluent{} if all reachable states satisfy the
  invariant.
\end{definition}

As we mentioned earlier, this definition of \Iconfluence{} is different than
the original definition presented in~\cite{bailis2014coordination} (though it
is the same as the definition in~\cite{gotsman2016cause}), but they are
(almost) equivalent. We introduce some definitions and then prove this.

\begin{definition}
  An expression \defword{recursively satisfies $I$}, denoted $\Irec{e}$, if $e$
  and all of $e$'s children satisfy $I$. That is,
  \begin{mathpar}
    \Irec{s_0} \defeq I(s_0)

    \Irec{t(e)} \defeq I(t(e)) \land \Irec{e}

    \Irec{e_1 \join e_2}
    \defeq I(e_1 \join e_2) \land \Irec{e_1} \land \Irec{e_2}
  \end{mathpar}
\end{definition}

Bailis et al.\ defined \Iconfluence{} to mean that expressions recursively
satisfying $I$ are closed under join. That is, $T$ is \Iconfluent{} if
\[
  \forall e_1, e_2.\; \Irec{e_1} \land \Irec{e_2} \implies I(e_1 \join e_2)
\]
If $\lnot I(s_0)$, then \Iconfluence{} holds vacuously which is a bit silly, so
Bailis et al.\ probably ought to have also added the condition $I(s_0)$ to
their definition of \Iconfluence{}. Doing so, the two definitions become
equivalent.

\begin{claim}\clmlabel{StateBasedIrecImpliesReachable}
  $\Irec{e} \implies \reachable{e}$
\end{claim}
\begin{elidableproof}
  We perform structural induction on $e$.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      Axiomatically, $\reachable{s_0}$.

    \item \textbf{Case $t(e)$.}
      $\Irec{t(e)}$, so $I(t(e))$ and $\Irec{e}$. By the inductive hypothesis,
      $\reachable{e}$, so by the definition of $\reachable{\cdot}$,
      $\reachable{t(e)}$.

    \item \textbf{Case $e_1 \join e_2$.}
      $\Irec{t(e)}$, so $\Irec{e_1}$ and $\Irec{e_2}$. By the inductive
      hypothesis, $\reachable{e_1}$ and $\reachable{e_2}$, so by the definition
      of $\reachable{\cdot}$, $\reachable{e_1 \join e_2}$.
  \end{itemize}
\end{elidableproof}

\begin{claim}\clmlabel{StateBasedTwoIconfluenceDefs}
  Consider a state based object $(S, s_0, \join)$, a set of transactions $T$,
  and an invariant $I$. The following two are equivalent:
  \begin{enumerate}[\quad(1)]
    \item
      $\setst{e}{\reachable{e}} \subseteq I$

    \item
      $I(s_0)$ and $\Irec{e_1} \land \Irec{e_2} \implies I(e_1 \join e_2)$
  \end{enumerate}
\end{claim}
\begin{elidableproof}
  First, we show that (1) implies (2). Axiomatically, $\reachable{s_0}$, so by
  (1), $I(s_0)$. Let $e_1$ and $e_2$ be arbitrary expressions such that
  $\Irec{e_1}$ and $\Irec{e_2}$. By \clmref{StateBasedIrecImpliesReachable},
  $\reachable{e_1}$ and $\reachable{e_2}$. Thus, $\reachable{e_1 \join e_2}$,
  so by (1), $I(e_1 \join e_2)$.

  Next, we show that (2) implies (1). We prove by structural induction that for
  all $e$, $\reachable{e} \implies \Irec{e}$. From this, (1) is immediate.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      $I(s_0)$ by (2), so $\Irec{s_0}$

    \item \textbf{Case $t(e)$.}
      $\reachable{t(e)}$, so $\reachable{e}$ and $I(t(e))$. By the inductive
      hypothesis, $\Irec{e}$, so by the definition of $\Irec{\cdot}$,
      $\Irec{t(e)}$.

    \item \textbf{Case $e_1 \join e_2$.}
      $\reachable{e_1 \join e_2}$, so $\reachable{e_1}$ and $\reachable{e_2}$.
      By the inductive hypothesis, $\Irec{e_1}$ and $\Irec{e_2}$. By $(2)$,
      $I(e_1 \join e_2)$. Thus, $\Irec{e_1 \join e_2}$.
  \end{itemize}
\end{elidableproof}

\subsection{Operation-Based}
\begin{definition}
  A \defword{distributed operation-based object} is a pair $(S, s_0)$ where $S$
  is a set of states and $s_0 \in S$ is a designated start state.
\end{definition}

Like state-based objects, the notion of operation-based objects is taken
from~\cite{shapiro2011conflict}. Note that we do not have a join function like
we did with state-based objects.

\begin{definition}
  An \defword{operation-based transaction} $t: S \to (S \to S)$ is a function
  that maps a state to a \defword{shadow transaction} $t(s): S \to S$. The term
  shadow transaction is taken from~\cite{li2014automating}.
\end{definition}

The definition of an invariant is the same in the state-based and
operation-based model.

\begin{example}
  $(\nats, 0)$ is a distributed object. $t(x) = y \mapsto x + y$ is a
  transaction that given a state $x$ returns a function $y \mapsto x + y$ that
  adds $x$ to its argument. $\setst{x \geq 0}{x \in \nats}$ is an invariant.
\end{example}

As with state-based objects, there are three ways to think about
operation-based \Iconfluence{}: a process-based approach, a graph-based
approach, and an expression-based approach. All three approaches are
illustrated in \figref{OpBasedModels} and are described in more detail below.

\input{figs/opbased_iconfluence.fig}

\subsubsection{Process-Based}
As with the state-based approach, the process-based model is most similar to
the process model described by Shapiro et al.\ in~\cite{shapiro2011conflict}.
We are given a set $\seq{p}{1}{n}$ of $n$ processors each of which begins with
state $s_0$. A processor $p_i$ can do one of two things.

First, $p_i$ can execute a transaction $t$ on its current state $s$ and then
transitions from state $s$ to state $t(s)(s)$, given that $I(t(s)(s))$. If
$\lnot I(t(s)(s))$, then $p_i$ will not perform $t$. If $p_i$ does execute $t$,
then it broadcasts $t(s)$ to all other processors exactly once.

Second, $p_i$ can receive a broadcasted shadow transaction $t(s_j)$ from some
other processor $p_j$. When $p_i$ receives $t(s_j)$, it transitions from its
state $s_i$ to state $t(s_j)(s_i)$. When $p_i$ receives a shadow transaction,
it must execute it, even if $\lnot I(t(s_j)(s_i))$.

$T$ is \Iconfluent{} if every reachable state (including $s_0$) satisfies the
invariant.

\subsubsection{Graph-Based}
In the graph-based model, we are given a directed acyclic graph in which each
vertex is a state $s$ and each edge is labelled with a shadow operation $t(s)$
where $s$ is some other vertex in the graph. $T$ is \Iconfluent{} if every
vertex in every graph satisfies $I$.

\subsubsection{Expression-Based}
Given an operation-based object $(S, s_0)$ and a set of transactions $T$, we
consider expressions built from the following grammar:
\[
  e ::= s_0 \mid t(e_1)(e_2)
\]
where $t$ corresponds to a transaction in $T$. We can evaluate an expression,
denoted $eval(e)$, in the obvious way:
\begin{mathpar}
  eval(s_0) \defeq s_0

  eval(t(e_1)(e_2)) \defeq t(eval(e_1))(eval(e_2))
\end{mathpar}

\begin{definition}
  An expression $e$ \defword{satisfies $I$}, denoted $I(e)$, if $I(eval(e))$.
\end{definition}

\begin{definition}
  As with state-based expressions, we formalize which operation-based
  expressions are reachable.

  \begin{mathpar}
    \inferrule{ }{\reachable{s_0}}

    \inferrule{
      \reachable{e_1} \\
      \reachable{e_2} \\
      I(t(e_1)(e_1))
    }{\reachable{t(e_1)(e_2)}}
  \end{mathpar}
\end{definition}

\begin{definition}
  $T$ is \Iconfluent{} if $\setst{e}{\reachable{e}} \subseteq I$.
\end{definition}

As with state-based objects, we have an equivalent definition of \Iconfluence{}
that deals with the closure of recursively invariant satisfying states.

\begin{definition}
  An expression \defword{recursively satisfies $I$}, denoted $\Irec{e}$, if $e$
  and all of $e$'s children satisfy $I$. That is,
  \begin{mathpar}
    \Irec{s_0} \defeq I(s_0)

    \Irec{t(e_1)(e_2)} \defeq I(t(e_1)(e_2)) \land \Irec{e_1} \land \Irec{e_2}
  \end{mathpar}
\end{definition}

\begin{claim}\clmlabel{OpBasedIrecImpliesReachable}
  $\Irec{e} \implies \reachable{e}$
\end{claim}
\begin{elidableproof}
  We perform a structural induction on $e$.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      Axiomatically, $\reachable{s_0}$.

    \item \textbf{Case $t(e_1)(e_2)$.}
      $\Irec{t(e_1)(e_2)}$, so $\Irec{e_1}$, $\Irec{e_2}$, and
      $I(t(e_1)(e_1))$. By the inductive hypothesis, $\reachable{e_1}$ and
      $\reachable{e_2}$. Thus, $\reachable{t(e_1)(e_2)}$.
  \end{itemize}
\end{elidableproof}

\begin{claim}\clmlabel{OpBasedTwoIconfluenceDefs}
  Given an operation-based object $(S, s_0)$, a set of transactions $T$, and an
  invariant $I$, the following two are equivalent:
  \begin{enumerate}[\quad(1)]
    \item
      $\setst{e}{\reachable{e}} \subseteq I$

    \item
      $I(s_0)$ and $\Irec{e_1} \land \Irec{e_2} \land I(t(e_1)(e_1)) \implies
      I(t(e_1)(e_2))$.
  \end{enumerate}
\end{claim}
\begin{elidableproof}
  First, we show that (1) implies (2). $\reachable{s_0}$, so by (1), $I(s_0)$.
  Let $e_1$ and $e_2$ be arbitrary expressions such that $\Irec{e_1}$,
  $\Irec{e_2}$, and $I(t(e_1)(e_1))$. By \clmref{OpBasedIrecImpliesReachable},
  $\reachable{e_1}$ and $\reachable{e_2}$, so $\reachable{t(e_1)(e_2)}$. By
  (1), $I(t(e_1)(e_2))$.

  Next, we show that (2) implies (1). We show by structural induction on $e$
  that $\reachable{e} \implies \Irec{e}$. From this, (1) is immediate.
  \begin{itemize}
    \item \textbf{Case $s_0$.}
      By (2), $I(s_0)$, so $\Irec{s_0}$.

    \item \textbf{Case $t(e_1)(e_2)$.}
      $\reachable{t(e_1)(e_2)}$, so $\reachable{e_1}$, $\reachable{e_2}$, and
      $I(t(e_1)(e_1))$. By the inductive hypothesis, $\Irec{e_1}$ and
      $\Irec{e_2}$. By (2), $I(t(e_1)(e_2))$, so $\Irec{t(e_1)(e_2)}$.
  \end{itemize}
\end{elidableproof}
