\section{\Iconfluence{}}
A \emph{distributed object} is a triple $(S, s_0, \join)$ where $S$ is a set of
states, $s_0 \in S$ is a designated start state, and $\join: S \times S \to S$
is a commutative binary merge operator. A \emph{transaction} $t: S \to S$ is a
function that maps one state to another. An \emph{invariant} $I: S \to
\set{\text{true}, \text{false}}$ is a predicate on states. For example,
$(\nats, +)$ is a distributed object, $t(x) = 2x$ is a transaction, and $I(x) =
x \geq 0$ is an invariant.

There are three ways to think about \Iconfluence{}: a process-based approach, a
graph-based approach, and an expression-based approach. All three approaches
are illustrated in \figref{threeconfluencemodels} and are described in more
detail below.

\input{iconfluence.fig}

\subsection{Process-Based}
The process-based model is most similar to the process model described by
Shapiro et al.\ in~\cite{shapiro2011conflict}. We are given a set
$\seq{p}{1}{n}$ of $n$ processors each of which begins with state $s_0$.
Processors can execute a transaction $t \in T$ to transition from state $s$ to
state $t(s)$, or they can send their state $s$ to another processor with state
$s'$ causing the other processor to transition from state $s'$ to state $s
\join s'$.

Consider any two processors $p_i$ and $p_j$ with states $s_i^0, \ldots, s_i^n$
and $s_j^0, \ldots, s_j^m$ such that every state $s_i^0, \ldots, s_i^n, s_j^0,
\ldots, s_j^m$ satisfies $I$. $T$ is invariant-confluent with respect to $I$,
abbreviated \Iconfluent{}, if $s_i^n \join s_j^m$ is guaranteed to satisfy $I$.

\subsection{Graph-Based}
The graph-based approach is most similar to the model used by Bailis et al.\
in~\cite{bailis2014coordination}. We are given a directed acyclic graph in
which vertices can have an arbitrary number of children but at most two
parents. The vertices are labelled with states, and the edges are either
labelled with transactions or are unlabelled if they correspond to a join. The
graph is really just an alternate way of representing an execution in the
process-based model, but with duplicate states collapsed into a single vertex.
As with the process-based model, we say $T$ is \Iconfluent{} if the join of any
two invariant satisfying states with invariant satisfying ancestors is
guaranteed to satisfy the invariant.

\subsection{Expression-Based}
The expression-based approach deals with expressions built from $s_0$,
transactions in $T$, and $\join$. That is, expressions $e$ are built from the
grammar
\[
  e ::= s_0 \mid t(e) \mid e_1 \join e_2
\]
where $t$ corresponds to a transaction in $T$. We can evaluate an expression,
denoted $eval(e)$, in the obvious way:
\begin{mathpar}
  eval(s_0) \defeq s_0

  eval(t(e)) \defeq t(eval(e))

  eval(e_1 \join e_2) \defeq eval(e_1) \join eval(e_2)
\end{mathpar}

We say an expression $e$ satisfies $I$ if $I(eval(e))$. We say an expression
recursively satisfies $I$, denoted $\Irec{e}$, if $e$ and all of $e$'s children
satisfy $I$. That is,
\begin{mathpar}
  \Irec{s_0} \defeq I(s_0)

  \Irec{t(e)} \defeq I(t(e)) \land I(e)

  \Irec{e_1 \join e_2} \defeq I(e_1 \join e_2) \land I(e_1) \land I(e_2)
\end{mathpar}

We say $T$ is \Iconfluent, if for all expressions $e_1, e_2$, if $\Irec{e_1}$
and $\Irec{e_2}$, then $I(e_1 \join e_2)$.
